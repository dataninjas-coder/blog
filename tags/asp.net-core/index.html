<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>asp.net core - Thomas Levesque&#39;s .NET Blog</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	
	
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="alternate" type="application/rss+xml" href="/tags/asp.net-core/index.xml" title="Thomas Levesque's .NET Blog">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-31621259-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Thomas Levesque&#39;s .NET Blog" rel="home">
				<div class="logo__title">Thomas Levesque&#39;s .NET Blog</div>
				
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">asp.net core</h1>
	</header><article class="list__item post">
	<header class="list__header">
		<h3 class="list__title post__title ">
			<a href="/2020/01/30/handling-query-string-parameters-with-no-value-in-asp-net-core/" rel="bookmark">
			Handling query string parameters with no value in ASP.NET Core
			</a>
		</h3>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Query strings are typically made of a sequence of key-value pairs, like ?foo=hello&amp;bar=world…. However, if you look at RFC 3986, you can see that query strings are very loosely specified. It mentions that
 query components are often used to carry identifying information in the form of &ldquo;key=value&rdquo; pairs
 But it&rsquo;s just an observation, not a rule (RFCs usually have very specific wording for rules, with words like MUST, SHOULD, etc.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h3 class="list__title post__title ">
			<a href="/2019/12/20/asp-net-core-when-environments-are-not-enough-use-sub-environments/" rel="bookmark">
			ASP.NET Core: when environments are not enough, use sub-environments!
			</a>
		</h3>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Out of the box, ASP.NET Core has the concept of &ldquo;environments&rdquo;, which allows your app to use different settings based on which environment it&rsquo;s running in. For instance, you can have Development/Staging/Production environments, each with its own settings file, and a common settings file shared by all environments:
 appsettings.json: global settings appsettings.Development.json: settings specific to the Development environment appsettings.Staging.json: settings specific to the Staging environment appsettings.Production.json: settings specific to the Production environment  With the default configuration, environment-specific settings just override global settings, so you don&rsquo;t have to specify unchanged settings in every environment if they&rsquo;re already specified in the global settings file.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h3 class="list__title post__title ">
			<a href="/2019/03/18/scaling-out-asp-net-core-signalr-using-azure-service-bus/" rel="bookmark">
			Scaling out ASP.NET Core SignalR using Azure Service Bus
			</a>
		</h3>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ASP.NET Core SignalR is a super easy way to establish two-way communication between an ASP.NET Core app and its clients, using WebSockets, Server-Sent Events, or long polling, depending on the client&rsquo;s capabilities. For instance, it can be used to send a notification to all connected clients. However, if you scale out your application to multiple server instances, it no longer works out of the box: only the clients connected to the instance that sent the notification will receive it.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h3 class="list__title post__title ">
			<a href="/2019/01/10/google-shutdown-fixing-google-authentication-in-asp-net-core/" rel="bookmark">
			Google&#43; shutdown: fixing Google authentication in ASP.NET Core
			</a>
		</h3>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A few months ago, Google decided to shutdown Google+, due to multiple data leaks. More recently, they announced that the Google+ APIs will be shutdown on March 7, 2019, which is pretty soon! In fact, calls to these APIs might start to fail as soon as January 28, which is less than 3 weeks from now. You might think that it doesn&rsquo;t affect you as a developer; but if you&rsquo;re using Google authentication in an ASP.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h3 class="list__title post__title ">
			<a href="/2018/12/24/multitenant-azure-ad-issuer-validation-in-asp-net-core/" rel="bookmark">
			Multitenant Azure AD issuer validation in ASP.NET Core
			</a>
		</h3>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		If you use Azure AD authentication and want to allow users from any tenant to connect to your ASP.NET Core application, you need to configure the Azure AD app as multi-tenant, and use a &ldquo;wildcard&rdquo; tenant id such as organizations or common in the authority URL:
openIdConnectOptions.Authority = &#34;https://login.microsoftonline.com/organizations/v2.0&#34;; The problem when you do that is that with the default configuration, the token validation will fail because the issuer in the token won&rsquo;t match the issuer specified in the OpenID metadata.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h3 class="list__title post__title ">
			<a href="/2018/09/25/asynchronous-initialization-in-asp-net-core-revisited/" rel="bookmark">
			Asynchronous initialization in ASP.NET Core, revisited
			</a>
		</h3>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Initialization in ASP.NET Core is a bit awkward. There are well defined places for registering services (the Startup.ConfigureServices method) and for building the middleware pipeline (the Startup.Configure method), but not for performing other initialization steps (e.g. pre-loading data, seeding a database, etc.).
Using a middleware: not such a good idea Two months ago I published a blog post about asynchronous initialization of an ASP.NET Core app using a custom middleware. At the time I was rather pleased with my solution, but a comment from Frantisek made me realize it wasn&rsquo;t such a good approach.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h3 class="list__title post__title ">
			<a href="/2018/09/04/handling-multipart-requests-with-json-and-file-uploads-in-asp-net-core/" rel="bookmark">
			Handling multipart requests with JSON and file uploads in ASP.NET Core
			</a>
		</h3>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Suppose we&rsquo;re writing an API for a blog. Our &ldquo;create post&rdquo; endpoint should receive the title, body, tags and an image to display at the top of the post. This raises a question: how do we send the image? There are at least 3 options:
 Embed the image bytes as base64 in the JSON payload, e.g.  { &#34;title&#34;: &#34;My first blog post&#34;, &#34;body&#34;: &#34;This is going to be the best blog EVER!
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h3 class="list__title post__title ">
			<a href="/2018/07/20/asynchronous-initialization-in-asp-net-core-with-custom-middleware/" rel="bookmark">
			Asynchronous initialization in ASP.NET Core with custom middleware
			</a>
		</h3>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Update: I no longer recommend the approach described in this post. I propose a better solution here: Asynchronous initialization in ASP.NET Core, revisited.
Sometimes you need to perform some initialization steps when your web application starts. However, putting such code in the Startup.Configure method is generally not a good idea, because:
 There&rsquo;s no current scope in the Configure method, so you can&rsquo;t use services registered with &ldquo;scoped&rdquo; lifetime (this would throw an InvalidOperationException: Cannot resolve scoped service &lsquo;MyApp.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h3 class="list__title post__title ">
			<a href="/2018/04/17/hosting-an-asp-net-core-2-application-on-a-raspberry-pi/" rel="bookmark">
			Hosting an ASP.NET Core 2 application on a Raspberry Pi
			</a>
		</h3>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		As you probably know, .NET Core runs on many platforms: Windows, macOS, and many UNIX/Linux variants, whether on x86/x64 architectures or on ARM. This enables a wide range of interesting scenarios&hellip; For instance, is a very small machine like a Raspberry Pi, which its low performance ARM processor and small amount of RAM (1 GB on my RPi 2 Model B), enough to host an ASP.NET Core web app? Yes it is!
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h3 class="list__title post__title ">
			<a href="/2018/03/27/understanding-the-asp-net-core-middleware-pipeline/" rel="bookmark">
			Understanding the ASP.NET Core middleware pipeline
			</a>
		</h3>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Middlewhat? The ASP.NET Core architecture features a system of middleware, which are pieces of code that handle requests and responses. Middleware are chained to each other to form a pipeline. Incoming requests are passed through the pipeline, where each middleware has a chance to do something with them before passing them to the next middleware. Outgoing responses are also passed through the pipeline, in reverse order. If this sounds very abstract, the following schema from the official ASP.
	</div>
</article>
</main>


			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 Thomas Levesque&#39;s .NET Blog.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>