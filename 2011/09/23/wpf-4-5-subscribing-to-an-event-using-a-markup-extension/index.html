<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>[WPF 4.5] Subscribing to an event using a markup extension | Thomas Levesque .NET Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.69.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="[WPF 4.5] Subscribing to an event using a markup extension" />
<meta property="og:description" content="It&rsquo;s been a while since I last wrote about markup extensions&hellip; The release of Visual Studio 11 Developer Preview, which introduces a number of new features to WPF, just gave me a reason to play with them again. The feature I&rsquo;m going to discuss here is perhaps not the most impressive, but it fills in a gap of the previous versions: the support of markup extensions for events. Until now, it was possible to use a markup extension in XAML to assign a value to a property, but we couldn&rsquo;t do the same to subscribe to an event." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog2.thomaslevesque.net/2011/09/23/wpf-4-5-subscribing-to-an-event-using-a-markup-extension/" />
<meta property="article:published_time" content="2011-09-23T11:32:07+00:00" />
<meta property="article:modified_time" content="2011-09-23T11:32:07+00:00" />
<meta itemprop="name" content="[WPF 4.5] Subscribing to an event using a markup extension">
<meta itemprop="description" content="It&rsquo;s been a while since I last wrote about markup extensions&hellip; The release of Visual Studio 11 Developer Preview, which introduces a number of new features to WPF, just gave me a reason to play with them again. The feature I&rsquo;m going to discuss here is perhaps not the most impressive, but it fills in a gap of the previous versions: the support of markup extensions for events. Until now, it was possible to use a markup extension in XAML to assign a value to a property, but we couldn&rsquo;t do the same to subscribe to an event.">
<meta itemprop="datePublished" content="2011-09-23T11:32:07&#43;00:00" />
<meta itemprop="dateModified" content="2011-09-23T11:32:07&#43;00:00" />
<meta itemprop="wordCount" content="1035">



<meta itemprop="keywords" content=".NET 4.5,events,markup extension,WPF,XAML," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[WPF 4.5] Subscribing to an event using a markup extension"/>
<meta name="twitter:description" content="It&rsquo;s been a while since I last wrote about markup extensions&hellip; The release of Visual Studio 11 Developer Preview, which introduces a number of new features to WPF, just gave me a reason to play with them again. The feature I&rsquo;m going to discuss here is perhaps not the most impressive, but it fills in a gap of the previous versions: the support of markup extensions for events. Until now, it was possible to use a markup extension in XAML to assign a value to a property, but we couldn&rsquo;t do the same to subscribe to an event."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://blog2.thomaslevesque.net/" class="f3 fw2 hover-white no-underline white-90 dib">
      Thomas Levesque .NET Blog
    </a>
    <div class="flex-l items-center">
      

      
      














    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://blog2.thomaslevesque.net/2011/09/23/wpf-4-5-subscribing-to-an-event-using-a-markup-extension/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://blog2.thomaslevesque.net/2011/09/23/wpf-4-5-subscribing-to-an-event-using-a-markup-extension/&amp;text=[WPF%204.5]%20Subscribing%20to%20an%20event%20using%20a%20markup%20extension" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog2.thomaslevesque.net/2011/09/23/wpf-4-5-subscribing-to-an-event-using-a-markup-extension/&amp;title=[WPF%204.5]%20Subscribing%20to%20an%20event%20using%20a%20markup%20extension" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>

      <h1 class="f1 athelas mt3 mb1">[WPF 4.5] Subscribing to an event using a markup extension</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2011-09-23T11:32:07Z">September 23, 2011</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>It&rsquo;s been a while since I last wrote about markup extensions&hellip; The release of <a href="http://msdn.microsoft.com/en-us/vstudio/hh127353">Visual Studio 11 Developer Preview</a>, which introduces a number of <a href="http://msdn.microsoft.com/en-us/library/bb613588%28v=VS.110%29.aspx">new features</a> to WPF, just gave me a reason to play with them again. The feature I&rsquo;m going to discuss here is perhaps not the most impressive, but it fills in a gap of the previous versions: the support of markup extensions for events.  Until now, it was possible to use a markup extension in XAML to assign a value to a property, but we couldn&rsquo;t do the same to subscribe to an event. In WPF 4.5, it is now possible. So here is a small example of the kind we can do with it&hellip;  When using the MVVM pattern, we often associate commands of the ViewModel with controls of the view, via the binding mechanism. This approach usually works well, but it has some downsides:</p>
<ul>
<li>
<p>it introduces a lot of boilerplate code in the ViewModel</p>
</li>
<li>
<p>not all controls have a <code>Command</code> property (actually, most don&rsquo;t), and when this property exists, it corresponds only to one event of the control (e.g. the click on a button). There is no really easy way to &ldquo;bind&rdquo; the other events to commands of the ViewModel</p>
<p>It would be nice to be able to bind events directly to ViewModel methods, like this:</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">        <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">Content=</span><span style="color:#e6db74">&#34;Click me&#34;</span>
                <span style="color:#a6e22e">Click=</span><span style="color:#e6db74">&#34;{my:EventBinding OnClick}&#34;</span> <span style="color:#f92672">/&gt;</span>
</code></pre></div><p>With the <code>OnClick</code> method defined in the ViewModel:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> OnClick(<span style="color:#66d9ef">object</span> sender, EventArgs e)
        {
            MessageBox.Show(<span style="color:#e6db74">&#34;Hello world!&#34;</span>);
        }
</code></pre></div><p>Well, this is now possible! Here&rsquo;s a proof of concept&hellip; The <code>EventBindingExtension</code> class shown below first gets the <code>DataContext</code> of the control, then looks for the specified method on the <code>DataContext</code>, and eventually returns a delegate for this method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">using</span> System;
<span style="color:#66d9ef">using</span> System.Collections.Generic;
<span style="color:#66d9ef">using</span> System.ComponentModel;
<span style="color:#66d9ef">using</span> System.Diagnostics;
<span style="color:#66d9ef">using</span> System.Linq;
<span style="color:#66d9ef">using</span> System.Reflection;
<span style="color:#66d9ef">using</span> System.Windows;
<span style="color:#66d9ef">using</span> System.Windows.Markup;


    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EventBindingExtension</span> : MarkupExtension
    {
        <span style="color:#66d9ef">public</span> EventBindingExtension() { }

        <span style="color:#66d9ef">public</span> EventBindingExtension(<span style="color:#66d9ef">string</span> eventHandlerName)
        {
            <span style="color:#66d9ef">this</span>.EventHandlerName = eventHandlerName;
        }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">        [ConstructorArgument(&#34;eventHandlerName&#34;)]</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> EventHandlerName { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">object</span> ProvideValue(IServiceProvider serviceProvider)
        {
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">string</span>.IsNullOrEmpty(EventHandlerName))
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentException(<span style="color:#e6db74">&#34;The EventHandlerName property is not set&#34;</span>, <span style="color:#e6db74">&#34;EventHandlerName&#34;</span>);

            <span style="color:#66d9ef">var</span> target = (IProvideValueTarget)serviceProvider.GetService(<span style="color:#66d9ef">typeof</span>(IProvideValueTarget));

            EventInfo eventInfo = target.TargetProperty <span style="color:#66d9ef">as</span> EventInfo;
            <span style="color:#66d9ef">if</span> (eventInfo == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidOperationException(<span style="color:#e6db74">&#34;The target property must be an event&#34;</span>);
            
            <span style="color:#66d9ef">object</span> dataContext = GetDataContext(target.TargetObject);
            <span style="color:#66d9ef">if</span> (dataContext == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidOperationException(<span style="color:#e6db74">&#34;No DataContext found&#34;</span>);

            <span style="color:#66d9ef">var</span> handler = GetHandler(dataContext, eventInfo, EventHandlerName);
            <span style="color:#66d9ef">if</span> (handler == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentException(<span style="color:#e6db74">&#34;No valid event handler was found&#34;</span>, <span style="color:#e6db74">&#34;EventHandlerName&#34;</span>);

            <span style="color:#66d9ef">return</span> handler;
        }

        <span style="color:#75715e">#region Helper methods
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">object</span> GetHandler(<span style="color:#66d9ef">object</span> dataContext, EventInfo eventInfo, <span style="color:#66d9ef">string</span> eventHandlerName)
        {
            Type dcType = dataContext.GetType();

            <span style="color:#66d9ef">var</span> method = dcType.GetMethod(
                eventHandlerName,
                GetParameterTypes(eventInfo));
            <span style="color:#66d9ef">if</span> (method != <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#66d9ef">if</span> (method.IsStatic)
                    <span style="color:#66d9ef">return</span> Delegate.CreateDelegate(eventInfo.EventHandlerType, method);
                <span style="color:#66d9ef">else</span>
                    <span style="color:#66d9ef">return</span> Delegate.CreateDelegate(eventInfo.EventHandlerType, dataContext, method);
            }

            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
        }

        <span style="color:#66d9ef">static</span> Type[] GetParameterTypes(EventInfo eventInfo)
        {
            <span style="color:#66d9ef">var</span> invokeMethod = eventInfo.EventHandlerType.GetMethod(<span style="color:#e6db74">&#34;Invoke&#34;</span>);
            <span style="color:#66d9ef">return</span> invokeMethod.GetParameters().Select(p =&gt; p.ParameterType).ToArray();
        }

        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">object</span> GetDataContext(<span style="color:#66d9ef">object</span> target)
        {
            <span style="color:#66d9ef">var</span> depObj = target <span style="color:#66d9ef">as</span> DependencyObject;
            <span style="color:#66d9ef">if</span> (depObj == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;

            <span style="color:#66d9ef">return</span> depObj.GetValue(FrameworkElement.DataContextProperty)
                ?? depObj.GetValue(FrameworkContentElement.DataContextProperty);
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>    }
</code></pre></div><p>This class can be used as shown in the example above.  As it is now, this markup extension has an annoying limitation: the <code>DataContext</code> must be set before the call to <code>ProvideValue</code>, otherwise it won&rsquo;t be possible to find the event handler method. A solution could be to subscribe to the <code>DataContextChanged</code> event to look for the method after the <code>DataContext</code> is set, but in the meantime we still need to return something&hellip; and we can&rsquo;t return null, because it would cause an exception (since you can&rsquo;t subscribe to an event with a null handler). So we need to return a dummy handler generated dynamically from the event signature. It makes things a bit harder&hellip; but it&rsquo;s still feasible.  Here&rsquo;s a second version that implements this improvement :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">using</span> System;
<span style="color:#66d9ef">using</span> System.Collections.Generic;
<span style="color:#66d9ef">using</span> System.ComponentModel;
<span style="color:#66d9ef">using</span> System.Diagnostics;
<span style="color:#66d9ef">using</span> System.Linq;
<span style="color:#66d9ef">using</span> System.Reflection;
<span style="color:#66d9ef">using</span> System.Reflection.Emit;
<span style="color:#66d9ef">using</span> System.Windows;
<span style="color:#66d9ef">using</span> System.Windows.Markup;

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EventBindingExtension</span> : MarkupExtension
    {
        <span style="color:#66d9ef">private</span> EventInfo _eventInfo;

        <span style="color:#66d9ef">public</span> EventBindingExtension() { }

        <span style="color:#66d9ef">public</span> EventBindingExtension(<span style="color:#66d9ef">string</span> eventHandlerName)
        {
            <span style="color:#66d9ef">this</span>.EventHandlerName = eventHandlerName;
        }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">        [ConstructorArgument(&#34;eventHandlerName&#34;)]</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> EventHandlerName { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">object</span> ProvideValue(IServiceProvider serviceProvider)
        {
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">string</span>.IsNullOrEmpty(EventHandlerName))
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentException(<span style="color:#e6db74">&#34;The EventHandlerName property is not set&#34;</span>, <span style="color:#e6db74">&#34;EventHandlerName&#34;</span>);

            <span style="color:#66d9ef">var</span> target = (IProvideValueTarget)serviceProvider.GetService(<span style="color:#66d9ef">typeof</span>(IProvideValueTarget));

            <span style="color:#66d9ef">var</span> targetObj = target.TargetObject <span style="color:#66d9ef">as</span> DependencyObject;
            <span style="color:#66d9ef">if</span> (targetObj == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidOperationException(<span style="color:#e6db74">&#34;The target object must be a DependencyObject&#34;</span>);

            _eventInfo = target.TargetProperty <span style="color:#66d9ef">as</span> EventInfo;
            <span style="color:#66d9ef">if</span> (_eventInfo == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidOperationException(<span style="color:#e6db74">&#34;The target property must be an event&#34;</span>);

            <span style="color:#66d9ef">object</span> dataContext = GetDataContext(targetObj);
            <span style="color:#66d9ef">if</span> (dataContext == <span style="color:#66d9ef">null</span>)
            {
                SubscribeToDataContextChanged(targetObj);
                <span style="color:#66d9ef">return</span> GetDummyHandler(_eventInfo.EventHandlerType);
            }

            <span style="color:#66d9ef">var</span> handler = GetHandler(dataContext, _eventInfo, EventHandlerName);
            <span style="color:#66d9ef">if</span> (handler == <span style="color:#66d9ef">null</span>)
            {
                Trace.TraceError(
                    <span style="color:#e6db74">&#34;EventBinding: no suitable method named &#39;{0}&#39; found in type &#39;{1}&#39; to handle event &#39;{2&#39;}&#34;</span>,
                    EventHandlerName,
                    dataContext.GetType(),
                    _eventInfo);
                <span style="color:#66d9ef">return</span> GetDummyHandler(_eventInfo.EventHandlerType);
            }

            <span style="color:#66d9ef">return</span> handler;
            
        }

        <span style="color:#75715e">#region Helper methods
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">static</span> Delegate GetHandler(<span style="color:#66d9ef">object</span> dataContext, EventInfo eventInfo, <span style="color:#66d9ef">string</span> eventHandlerName)
        {
            Type dcType = dataContext.GetType();

            <span style="color:#66d9ef">var</span> method = dcType.GetMethod(
                eventHandlerName,
                GetParameterTypes(eventInfo.EventHandlerType));
            <span style="color:#66d9ef">if</span> (method != <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#66d9ef">if</span> (method.IsStatic)
                    <span style="color:#66d9ef">return</span> Delegate.CreateDelegate(eventInfo.EventHandlerType, method);
                <span style="color:#66d9ef">else</span>
                    <span style="color:#66d9ef">return</span> Delegate.CreateDelegate(eventInfo.EventHandlerType, dataContext, method);
            }

            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
        }

        <span style="color:#66d9ef">static</span> Type[] GetParameterTypes(Type delegateType)
        {
            <span style="color:#66d9ef">var</span> invokeMethod = delegateType.GetMethod(<span style="color:#e6db74">&#34;Invoke&#34;</span>);
            <span style="color:#66d9ef">return</span> invokeMethod.GetParameters().Select(p =&gt; p.ParameterType).ToArray();
        }

        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">object</span> GetDataContext(DependencyObject target)
        {
            <span style="color:#66d9ef">return</span> target.GetValue(FrameworkElement.DataContextProperty)
                ?? target.GetValue(FrameworkContentElement.DataContextProperty);
        }

        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Dictionary&lt;Type, Delegate&gt; _dummyHandlers = <span style="color:#66d9ef">new</span> Dictionary&lt;Type, Delegate&gt;();

        <span style="color:#66d9ef">static</span> Delegate GetDummyHandler(Type eventHandlerType)
        {
            Delegate handler;
            <span style="color:#66d9ef">if</span> (!_dummyHandlers.TryGetValue(eventHandlerType, <span style="color:#66d9ef">out</span> handler))
            {
                handler = CreateDummyHandler(eventHandlerType);
                _dummyHandlers[eventHandlerType] = handler;
            }
            <span style="color:#66d9ef">return</span> handler;
        }

        <span style="color:#66d9ef">static</span> Delegate CreateDummyHandler(Type eventHandlerType)
        {
            <span style="color:#66d9ef">var</span> parameterTypes = GetParameterTypes(eventHandlerType);
            <span style="color:#66d9ef">var</span> returnType = eventHandlerType.GetMethod(<span style="color:#e6db74">&#34;Invoke&#34;</span>).ReturnType;
            <span style="color:#66d9ef">var</span> dm = <span style="color:#66d9ef">new</span> DynamicMethod(<span style="color:#e6db74">&#34;DummyHandler&#34;</span>, returnType, parameterTypes);
            <span style="color:#66d9ef">var</span> il = dm.GetILGenerator();
            <span style="color:#66d9ef">if</span> (returnType != <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">void</span>))
            {
                <span style="color:#66d9ef">if</span> (returnType.IsValueType)
                {
                    <span style="color:#66d9ef">var</span> local = il.DeclareLocal(returnType);
                    il.Emit(OpCodes.Ldloca_S, local);
                    il.Emit(OpCodes.Initobj, returnType);
                    il.Emit(OpCodes.Ldloc_0);
                }
                <span style="color:#66d9ef">else</span>
                {
                    il.Emit(OpCodes.Ldnull);
                }
            }
            il.Emit(OpCodes.Ret);
            <span style="color:#66d9ef">return</span> dm.CreateDelegate(eventHandlerType);
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> SubscribeToDataContextChanged(DependencyObject targetObj)
        {
            DependencyPropertyDescriptor
                .FromProperty(FrameworkElement.DataContextProperty, targetObj.GetType())
                .AddValueChanged(targetObj, TargetObject_DataContextChanged);
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> UnsubscribeFromDataContextChanged(DependencyObject targetObj)
        {
            DependencyPropertyDescriptor
                .FromProperty(FrameworkElement.DataContextProperty, targetObj.GetType())
                .RemoveValueChanged(targetObj, TargetObject_DataContextChanged);
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> TargetObject_DataContextChanged(<span style="color:#66d9ef">object</span> sender, EventArgs e)
        {
            DependencyObject targetObj = sender <span style="color:#66d9ef">as</span> DependencyObject;
            <span style="color:#66d9ef">if</span> (targetObj == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">return</span>;

            <span style="color:#66d9ef">object</span> dataContext = GetDataContext(targetObj);
            <span style="color:#66d9ef">if</span> (dataContext == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">return</span>;

            <span style="color:#66d9ef">var</span> handler = GetHandler(dataContext, _eventInfo, EventHandlerName);
            <span style="color:#66d9ef">if</span> (handler != <span style="color:#66d9ef">null</span>)
            {
                _eventInfo.AddEventHandler(targetObj, handler);
            }
            UnsubscribeFromDataContextChanged(targetObj);
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>    }
</code></pre></div><p>So this is the kind of things we can do thanks to this new WPF feature. We could also imagine a behavior system similar to what we can do with attached properties, e.g. to execute a standard action when an event occurs. There are lots of possible applications for this, I leave it to you to find them ;)</p>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/.net-4.5" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">.NET 4.5</a>
   </li>
  
   <li class="list">
     <a href="/tags/events" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">events</a>
   </li>
  
   <li class="list">
     <a href="/tags/markup-extension" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">markup extension</a>
   </li>
  
   <li class="list">
     <a href="/tags/wpf" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">WPF</a>
   </li>
  
   <li class="list">
     <a href="/tags/xaml" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">XAML</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/2009/08/23/wpf-markup-extensions-and-templates/">[WPF] Markup extensions and templates</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2009/07/28/wpf-a-markup-extension-that-can-update-its-target/">[WPF] A markup extension that can update its target</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2009/03/17/wpf-using-inputbindings-with-the-mvvm-pattern/">[WPF] Using InputBindings with the MVVM pattern</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2008/11/18/wpf-binding-to-application-settings-using-a-markup-extension/">[WPF] Binding to application settings using a markup extension</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2010/07/20/wpf-a-simpler-grid-using-xaml-attribute-syntax/">[WPF] A simpler Grid using XAML attribute syntax</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2009/10/26/vs2010-binding-support-in-inputbindings/">[VS2010] Binding support in InputBindings</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2009/08/04/wpf-automatically-sort-a-gridview-continued/">[WPF] Automatically sort a GridView (continued)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2011/03/27/wpf-display-an-animated-gif-image/">[WPF] Display an animated GIF image</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2011/03/21/wpf-how-to-bind-to-data-when-the-datacontext-is-not-inherited/">[WPF] How to bind to data when the DataContext is not inherited</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2009/04/17/wpf-binding-to-an-asynchronous-collection/">[WPF] Binding to an asynchronous collection</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2009/03/27/wpf-automatically-sort-a-gridview-when-a-column-header-is-clicked/">[WPF] Automatically sort a GridView when a column header is clicked</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2009/02/25/wpf-article-about-model-view-viewmodel-design-pattern-by-josh-smith/">[WPF] Article about the Model-View-ViewModel design pattern, by Josh Smith</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2009/02/13/build-an-rss-reader-in-5-minutes/">Build an RSS reader in 5 minutes</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2009/02/05/wpf-paste-an-image-from-the-clipboard/">[WPF] Paste an image from the clipboard (bug in Clipboard.GetImage)</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://blog2.thomaslevesque.net/" >
    &copy;  Thomas Levesque .NET Blog 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
