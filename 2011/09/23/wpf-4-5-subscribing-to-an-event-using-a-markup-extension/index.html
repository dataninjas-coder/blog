<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>[WPF 4.5] Subscribing to an event using a markup extension - Thomas Levesque&#39;s .NET Blog</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	
	
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-31621259-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Thomas Levesque&#39;s .NET Blog" rel="home">
				<div class="logo__title">Thomas Levesque&#39;s .NET Blog</div>
				
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[WPF 4.5] Subscribing to an event using a markup extension</h1>
			
		</header><div class="content post__content clearfix">
			<p>It&rsquo;s been a while since I last wrote about markup extensions&hellip; The release of <a href="http://msdn.microsoft.com/en-us/vstudio/hh127353">Visual Studio 11 Developer Preview</a>, which introduces a number of <a href="http://msdn.microsoft.com/en-us/library/bb613588%28v=VS.110%29.aspx">new features</a> to WPF, just gave me a reason to play with them again. The feature I&rsquo;m going to discuss here is perhaps not the most impressive, but it fills in a gap of the previous versions: the support of markup extensions for events.  Until now, it was possible to use a markup extension in XAML to assign a value to a property, but we couldn&rsquo;t do the same to subscribe to an event. In WPF 4.5, it is now possible. So here is a small example of the kind we can do with it&hellip;  When using the MVVM pattern, we often associate commands of the ViewModel with controls of the view, via the binding mechanism. This approach usually works well, but it has some downsides:</p>
<ul>
<li>
<p>it introduces a lot of boilerplate code in the ViewModel</p>
</li>
<li>
<p>not all controls have a <code>Command</code> property (actually, most don&rsquo;t), and when this property exists, it corresponds only to one event of the control (e.g. the click on a button). There is no really easy way to &ldquo;bind&rdquo; the other events to commands of the ViewModel</p>
<p>It would be nice to be able to bind events directly to ViewModel methods, like this:</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">        <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">Content=</span><span style="color:#e6db74">&#34;Click me&#34;</span>
                <span style="color:#a6e22e">Click=</span><span style="color:#e6db74">&#34;{my:EventBinding OnClick}&#34;</span> <span style="color:#f92672">/&gt;</span>
</code></pre></div><p>With the <code>OnClick</code> method defined in the ViewModel:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> OnClick(<span style="color:#66d9ef">object</span> sender, EventArgs e)
        {
            MessageBox.Show(<span style="color:#e6db74">&#34;Hello world!&#34;</span>);
        }
</code></pre></div><p>Well, this is now possible! Here&rsquo;s a proof of concept&hellip; The <code>EventBindingExtension</code> class shown below first gets the <code>DataContext</code> of the control, then looks for the specified method on the <code>DataContext</code>, and eventually returns a delegate for this method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">using</span> System;
<span style="color:#66d9ef">using</span> System.Collections.Generic;
<span style="color:#66d9ef">using</span> System.ComponentModel;
<span style="color:#66d9ef">using</span> System.Diagnostics;
<span style="color:#66d9ef">using</span> System.Linq;
<span style="color:#66d9ef">using</span> System.Reflection;
<span style="color:#66d9ef">using</span> System.Windows;
<span style="color:#66d9ef">using</span> System.Windows.Markup;


    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EventBindingExtension</span> : MarkupExtension
    {
        <span style="color:#66d9ef">public</span> EventBindingExtension() { }

        <span style="color:#66d9ef">public</span> EventBindingExtension(<span style="color:#66d9ef">string</span> eventHandlerName)
        {
            <span style="color:#66d9ef">this</span>.EventHandlerName = eventHandlerName;
        }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">        [ConstructorArgument(&#34;eventHandlerName&#34;)]</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> EventHandlerName { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">object</span> ProvideValue(IServiceProvider serviceProvider)
        {
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">string</span>.IsNullOrEmpty(EventHandlerName))
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentException(<span style="color:#e6db74">&#34;The EventHandlerName property is not set&#34;</span>, <span style="color:#e6db74">&#34;EventHandlerName&#34;</span>);

            <span style="color:#66d9ef">var</span> target = (IProvideValueTarget)serviceProvider.GetService(<span style="color:#66d9ef">typeof</span>(IProvideValueTarget));

            EventInfo eventInfo = target.TargetProperty <span style="color:#66d9ef">as</span> EventInfo;
            <span style="color:#66d9ef">if</span> (eventInfo == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidOperationException(<span style="color:#e6db74">&#34;The target property must be an event&#34;</span>);
            
            <span style="color:#66d9ef">object</span> dataContext = GetDataContext(target.TargetObject);
            <span style="color:#66d9ef">if</span> (dataContext == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidOperationException(<span style="color:#e6db74">&#34;No DataContext found&#34;</span>);

            <span style="color:#66d9ef">var</span> handler = GetHandler(dataContext, eventInfo, EventHandlerName);
            <span style="color:#66d9ef">if</span> (handler == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentException(<span style="color:#e6db74">&#34;No valid event handler was found&#34;</span>, <span style="color:#e6db74">&#34;EventHandlerName&#34;</span>);

            <span style="color:#66d9ef">return</span> handler;
        }

        <span style="color:#75715e">#region Helper methods
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">object</span> GetHandler(<span style="color:#66d9ef">object</span> dataContext, EventInfo eventInfo, <span style="color:#66d9ef">string</span> eventHandlerName)
        {
            Type dcType = dataContext.GetType();

            <span style="color:#66d9ef">var</span> method = dcType.GetMethod(
                eventHandlerName,
                GetParameterTypes(eventInfo));
            <span style="color:#66d9ef">if</span> (method != <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#66d9ef">if</span> (method.IsStatic)
                    <span style="color:#66d9ef">return</span> Delegate.CreateDelegate(eventInfo.EventHandlerType, method);
                <span style="color:#66d9ef">else</span>
                    <span style="color:#66d9ef">return</span> Delegate.CreateDelegate(eventInfo.EventHandlerType, dataContext, method);
            }

            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
        }

        <span style="color:#66d9ef">static</span> Type[] GetParameterTypes(EventInfo eventInfo)
        {
            <span style="color:#66d9ef">var</span> invokeMethod = eventInfo.EventHandlerType.GetMethod(<span style="color:#e6db74">&#34;Invoke&#34;</span>);
            <span style="color:#66d9ef">return</span> invokeMethod.GetParameters().Select(p =&gt; p.ParameterType).ToArray();
        }

        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">object</span> GetDataContext(<span style="color:#66d9ef">object</span> target)
        {
            <span style="color:#66d9ef">var</span> depObj = target <span style="color:#66d9ef">as</span> DependencyObject;
            <span style="color:#66d9ef">if</span> (depObj == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;

            <span style="color:#66d9ef">return</span> depObj.GetValue(FrameworkElement.DataContextProperty)
                ?? depObj.GetValue(FrameworkContentElement.DataContextProperty);
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>    }
</code></pre></div><p>This class can be used as shown in the example above.  As it is now, this markup extension has an annoying limitation: the <code>DataContext</code> must be set before the call to <code>ProvideValue</code>, otherwise it won&rsquo;t be possible to find the event handler method. A solution could be to subscribe to the <code>DataContextChanged</code> event to look for the method after the <code>DataContext</code> is set, but in the meantime we still need to return something&hellip; and we can&rsquo;t return null, because it would cause an exception (since you can&rsquo;t subscribe to an event with a null handler). So we need to return a dummy handler generated dynamically from the event signature. It makes things a bit harder&hellip; but it&rsquo;s still feasible.  Here&rsquo;s a second version that implements this improvement :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">using</span> System;
<span style="color:#66d9ef">using</span> System.Collections.Generic;
<span style="color:#66d9ef">using</span> System.ComponentModel;
<span style="color:#66d9ef">using</span> System.Diagnostics;
<span style="color:#66d9ef">using</span> System.Linq;
<span style="color:#66d9ef">using</span> System.Reflection;
<span style="color:#66d9ef">using</span> System.Reflection.Emit;
<span style="color:#66d9ef">using</span> System.Windows;
<span style="color:#66d9ef">using</span> System.Windows.Markup;

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EventBindingExtension</span> : MarkupExtension
    {
        <span style="color:#66d9ef">private</span> EventInfo _eventInfo;

        <span style="color:#66d9ef">public</span> EventBindingExtension() { }

        <span style="color:#66d9ef">public</span> EventBindingExtension(<span style="color:#66d9ef">string</span> eventHandlerName)
        {
            <span style="color:#66d9ef">this</span>.EventHandlerName = eventHandlerName;
        }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">        [ConstructorArgument(&#34;eventHandlerName&#34;)]</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> EventHandlerName { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">object</span> ProvideValue(IServiceProvider serviceProvider)
        {
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">string</span>.IsNullOrEmpty(EventHandlerName))
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentException(<span style="color:#e6db74">&#34;The EventHandlerName property is not set&#34;</span>, <span style="color:#e6db74">&#34;EventHandlerName&#34;</span>);

            <span style="color:#66d9ef">var</span> target = (IProvideValueTarget)serviceProvider.GetService(<span style="color:#66d9ef">typeof</span>(IProvideValueTarget));

            <span style="color:#66d9ef">var</span> targetObj = target.TargetObject <span style="color:#66d9ef">as</span> DependencyObject;
            <span style="color:#66d9ef">if</span> (targetObj == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidOperationException(<span style="color:#e6db74">&#34;The target object must be a DependencyObject&#34;</span>);

            _eventInfo = target.TargetProperty <span style="color:#66d9ef">as</span> EventInfo;
            <span style="color:#66d9ef">if</span> (_eventInfo == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidOperationException(<span style="color:#e6db74">&#34;The target property must be an event&#34;</span>);

            <span style="color:#66d9ef">object</span> dataContext = GetDataContext(targetObj);
            <span style="color:#66d9ef">if</span> (dataContext == <span style="color:#66d9ef">null</span>)
            {
                SubscribeToDataContextChanged(targetObj);
                <span style="color:#66d9ef">return</span> GetDummyHandler(_eventInfo.EventHandlerType);
            }

            <span style="color:#66d9ef">var</span> handler = GetHandler(dataContext, _eventInfo, EventHandlerName);
            <span style="color:#66d9ef">if</span> (handler == <span style="color:#66d9ef">null</span>)
            {
                Trace.TraceError(
                    <span style="color:#e6db74">&#34;EventBinding: no suitable method named &#39;{0}&#39; found in type &#39;{1}&#39; to handle event &#39;{2&#39;}&#34;</span>,
                    EventHandlerName,
                    dataContext.GetType(),
                    _eventInfo);
                <span style="color:#66d9ef">return</span> GetDummyHandler(_eventInfo.EventHandlerType);
            }

            <span style="color:#66d9ef">return</span> handler;
            
        }

        <span style="color:#75715e">#region Helper methods
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">static</span> Delegate GetHandler(<span style="color:#66d9ef">object</span> dataContext, EventInfo eventInfo, <span style="color:#66d9ef">string</span> eventHandlerName)
        {
            Type dcType = dataContext.GetType();

            <span style="color:#66d9ef">var</span> method = dcType.GetMethod(
                eventHandlerName,
                GetParameterTypes(eventInfo.EventHandlerType));
            <span style="color:#66d9ef">if</span> (method != <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#66d9ef">if</span> (method.IsStatic)
                    <span style="color:#66d9ef">return</span> Delegate.CreateDelegate(eventInfo.EventHandlerType, method);
                <span style="color:#66d9ef">else</span>
                    <span style="color:#66d9ef">return</span> Delegate.CreateDelegate(eventInfo.EventHandlerType, dataContext, method);
            }

            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
        }

        <span style="color:#66d9ef">static</span> Type[] GetParameterTypes(Type delegateType)
        {
            <span style="color:#66d9ef">var</span> invokeMethod = delegateType.GetMethod(<span style="color:#e6db74">&#34;Invoke&#34;</span>);
            <span style="color:#66d9ef">return</span> invokeMethod.GetParameters().Select(p =&gt; p.ParameterType).ToArray();
        }

        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">object</span> GetDataContext(DependencyObject target)
        {
            <span style="color:#66d9ef">return</span> target.GetValue(FrameworkElement.DataContextProperty)
                ?? target.GetValue(FrameworkContentElement.DataContextProperty);
        }

        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Dictionary&lt;Type, Delegate&gt; _dummyHandlers = <span style="color:#66d9ef">new</span> Dictionary&lt;Type, Delegate&gt;();

        <span style="color:#66d9ef">static</span> Delegate GetDummyHandler(Type eventHandlerType)
        {
            Delegate handler;
            <span style="color:#66d9ef">if</span> (!_dummyHandlers.TryGetValue(eventHandlerType, <span style="color:#66d9ef">out</span> handler))
            {
                handler = CreateDummyHandler(eventHandlerType);
                _dummyHandlers[eventHandlerType] = handler;
            }
            <span style="color:#66d9ef">return</span> handler;
        }

        <span style="color:#66d9ef">static</span> Delegate CreateDummyHandler(Type eventHandlerType)
        {
            <span style="color:#66d9ef">var</span> parameterTypes = GetParameterTypes(eventHandlerType);
            <span style="color:#66d9ef">var</span> returnType = eventHandlerType.GetMethod(<span style="color:#e6db74">&#34;Invoke&#34;</span>).ReturnType;
            <span style="color:#66d9ef">var</span> dm = <span style="color:#66d9ef">new</span> DynamicMethod(<span style="color:#e6db74">&#34;DummyHandler&#34;</span>, returnType, parameterTypes);
            <span style="color:#66d9ef">var</span> il = dm.GetILGenerator();
            <span style="color:#66d9ef">if</span> (returnType != <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">void</span>))
            {
                <span style="color:#66d9ef">if</span> (returnType.IsValueType)
                {
                    <span style="color:#66d9ef">var</span> local = il.DeclareLocal(returnType);
                    il.Emit(OpCodes.Ldloca_S, local);
                    il.Emit(OpCodes.Initobj, returnType);
                    il.Emit(OpCodes.Ldloc_0);
                }
                <span style="color:#66d9ef">else</span>
                {
                    il.Emit(OpCodes.Ldnull);
                }
            }
            il.Emit(OpCodes.Ret);
            <span style="color:#66d9ef">return</span> dm.CreateDelegate(eventHandlerType);
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> SubscribeToDataContextChanged(DependencyObject targetObj)
        {
            DependencyPropertyDescriptor
                .FromProperty(FrameworkElement.DataContextProperty, targetObj.GetType())
                .AddValueChanged(targetObj, TargetObject_DataContextChanged);
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> UnsubscribeFromDataContextChanged(DependencyObject targetObj)
        {
            DependencyPropertyDescriptor
                .FromProperty(FrameworkElement.DataContextProperty, targetObj.GetType())
                .RemoveValueChanged(targetObj, TargetObject_DataContextChanged);
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> TargetObject_DataContextChanged(<span style="color:#66d9ef">object</span> sender, EventArgs e)
        {
            DependencyObject targetObj = sender <span style="color:#66d9ef">as</span> DependencyObject;
            <span style="color:#66d9ef">if</span> (targetObj == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">return</span>;

            <span style="color:#66d9ef">object</span> dataContext = GetDataContext(targetObj);
            <span style="color:#66d9ef">if</span> (dataContext == <span style="color:#66d9ef">null</span>)
                <span style="color:#66d9ef">return</span>;

            <span style="color:#66d9ef">var</span> handler = GetHandler(dataContext, _eventInfo, EventHandlerName);
            <span style="color:#66d9ef">if</span> (handler != <span style="color:#66d9ef">null</span>)
            {
                _eventInfo.AddEventHandler(targetObj, handler);
            }
            UnsubscribeFromDataContextChanged(targetObj);
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>    }
</code></pre></div><p>So this is the kind of things we can do thanks to this new WPF feature. We could also imagine a behavior system similar to what we can do with attached properties, e.g. to execute a standard action when an event occurs. There are lots of possible applications for this, I leave it to you to find them ;)</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/.net-4.5/" rel="tag">.NET 4.5</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/events/" rel="tag">events</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/markup-extension/" rel="tag">markup extension</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/wpf/" rel="tag">WPF</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/xaml/" rel="tag">XAML</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>





			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 Thomas Levesque&#39;s .NET Blog.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>