<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>[C#] A simple implementation of the WeakEvent pattern | Thomas Levesque .NET Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.69.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="[C#] A simple implementation of the WeakEvent pattern" />
<meta property="og:description" content="As you probably know, incorrect usage of events is one of the main causes for memory leaks in .NET applications : an event keeps references to its listener objects (through a delegate), which prevents the garbage collector from collecting them when they&rsquo;re not used anymore. This is especially true of static events, because the references are kept for all the lifetime of the application. If the application often adds handlers to the event and never removes them, the memory usage will grow as long as the application runs, until no more memory is available." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog2.thomaslevesque.net/2010/05/17/c-a-simple-implementation-of-the-weakevent-pattern/" />
<meta property="article:published_time" content="2010-05-17T21:12:36+00:00" />
<meta property="article:modified_time" content="2010-05-17T21:12:36+00:00" />
<meta itemprop="name" content="[C#] A simple implementation of the WeakEvent pattern">
<meta itemprop="description" content="As you probably know, incorrect usage of events is one of the main causes for memory leaks in .NET applications : an event keeps references to its listener objects (through a delegate), which prevents the garbage collector from collecting them when they&rsquo;re not used anymore. This is especially true of static events, because the references are kept for all the lifetime of the application. If the application often adds handlers to the event and never removes them, the memory usage will grow as long as the application runs, until no more memory is available.">
<meta itemprop="datePublished" content="2010-05-17T21:12:36&#43;00:00" />
<meta itemprop="dateModified" content="2010-05-17T21:12:36&#43;00:00" />
<meta itemprop="wordCount" content="813">



<meta itemprop="keywords" content="C#,code snippet,weak event," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[C#] A simple implementation of the WeakEvent pattern"/>
<meta name="twitter:description" content="As you probably know, incorrect usage of events is one of the main causes for memory leaks in .NET applications : an event keeps references to its listener objects (through a delegate), which prevents the garbage collector from collecting them when they&rsquo;re not used anymore. This is especially true of static events, because the references are kept for all the lifetime of the application. If the application often adds handlers to the event and never removes them, the memory usage will grow as long as the application runs, until no more memory is available."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://blog2.thomaslevesque.net/" class="f3 fw2 hover-white no-underline white-90 dib">
      Thomas Levesque .NET Blog
    </a>
    <div class="flex-l items-center">
      

      
      














    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://blog2.thomaslevesque.net/2010/05/17/c-a-simple-implementation-of-the-weakevent-pattern/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://blog2.thomaslevesque.net/2010/05/17/c-a-simple-implementation-of-the-weakevent-pattern/&amp;text=[C#]%20A%20simple%20implementation%20of%20the%20WeakEvent%20pattern" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog2.thomaslevesque.net/2010/05/17/c-a-simple-implementation-of-the-weakevent-pattern/&amp;title=[C#]%20A%20simple%20implementation%20of%20the%20WeakEvent%20pattern" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>

      <h1 class="f1 athelas mt3 mb1">[C#] A simple implementation of the WeakEvent pattern</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2010-05-17T21:12:36Z">May 17, 2010</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>As you probably know, incorrect usage of events is one of the main causes for memory leaks in .NET applications : an event keeps references to its listener objects (through a delegate), which prevents the garbage collector from collecting them when they&rsquo;re not used anymore. This is especially true of static events, because the references are kept for all the lifetime of the application. If the application often adds handlers to the event and never removes them, the memory usage will grow as long as the application runs, until no more memory is available.  The &ldquo;obvious&rdquo; solution, of course, is to unsubscribe from the event when you&rsquo;re done with it. Unfortunately, it&rsquo;s not always obvious to know <em>when</em> you can unsubscribe&hellip; an object that goes out of scope usually isn&rsquo;t aware of it, so it doesn&rsquo;t have a chance to unsubscribe from the event.  Another approach is to implement the <a href="http://msdn.microsoft.com/en-us/library/aa970850.aspx">WeakEvent pattern</a>, which principle is to keep only weak references to the listeners. That way, unsubscribed listeners can be claimed by the garbage collector. Microsoft included in WPF a few types to deal with the WeakEvent pattern (<code>WeakEventManager</code> class and <code>IWeakEventListener</code> interface), and gives guidelines on how to implement your own weak event. However this technique is not very convenient, because you need to create dedicated classes to expose new events, and the listeners need to implement a specific interface.  So I thought about another implementation, which allows creating weak events almost the same way as normal events. My first idea was to use a list of <code>WeakReference</code>s to store the list of subscribed delegates. But this doesn&rsquo;t work so well, because of the way we typically use delegates :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">
myObject.MyEvent += <span style="color:#66d9ef">new</span> EventHandler(myObject_MyEvent);
</code></pre></div><p>We create a delegate, subscribe it to the event, and&hellip; drop it. So the only accessible reference to the delegate is actually a weak reference, so there&rsquo;s nothing to prevent its garbage collection&hellip; and that&rsquo;s exactly what happens ! After a variable period of time (from my observations, no more than a few seconds), the delegate is garbage collected, and isn&rsquo;t called anymore when the event is raised.  Rather than keeping a weak reference to the delegate itself, we should use a less transient object : the target object of the delegate (<code>Delegate.Target</code>) would be a better choice. So I created the <code>WeakDelegate&lt;TDelegate&gt;</code> class, which wraps a delegate by storing separately the method and a weak reference to the target :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WeakDelegate</span>&lt;TDelegate&gt; : IEquatable&lt;TDelegate&gt;
    {
        <span style="color:#66d9ef">private</span> WeakReference _targetReference;
        <span style="color:#66d9ef">private</span> MethodInfo _method;

        <span style="color:#66d9ef">public</span> WeakDelegate(Delegate realDelegate)
        {
            <span style="color:#66d9ef">if</span> (realDelegate.Target != <span style="color:#66d9ef">null</span>)
                _targetReference = <span style="color:#66d9ef">new</span> WeakReference(realDelegate.Target);
            <span style="color:#66d9ef">else</span>
                _targetReference = <span style="color:#66d9ef">null</span>;
            _method = realDelegate.Method;
        }

        <span style="color:#66d9ef">public</span> TDelegate GetDelegate()
        {
            <span style="color:#66d9ef">return</span> (TDelegate)(<span style="color:#66d9ef">object</span>)GetDelegateInternal();
        }

        <span style="color:#66d9ef">private</span> Delegate GetDelegateInternal()
        {
            <span style="color:#66d9ef">if</span> (_targetReference != <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#66d9ef">return</span> Delegate.CreateDelegate(<span style="color:#66d9ef">typeof</span>(TDelegate), _targetReference.Target, _method);
            }
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#66d9ef">return</span> Delegate.CreateDelegate(<span style="color:#66d9ef">typeof</span>(TDelegate), _method);
            }
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsAlive
        {
            <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> _targetReference == <span style="color:#66d9ef">null</span> || _targetReference.IsAlive; }
        }


        <span style="color:#75715e">#region IEquatable&lt;TDelegate&gt; Members
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Equals(TDelegate other)
        {
            Delegate d = (Delegate)(<span style="color:#66d9ef">object</span>)other;
            <span style="color:#66d9ef">return</span> d != <span style="color:#66d9ef">null</span>
                &amp;&amp; d.Target == _targetReference.Target
                &amp;&amp; d.Method.Equals(_method);
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">void</span> Invoke(<span style="color:#66d9ef">params</span> <span style="color:#66d9ef">object</span>[] args)
        {
            Delegate handler = (Delegate)(<span style="color:#66d9ef">object</span>)GetDelegateInternal();
            handler.DynamicInvoke(args);
        }
    }
</code></pre></div><p>Now, we just need to manage a list of these <code>WeakDelegate&lt;TDelegate&gt;</code>. This is done by the <code>WeakEvent&lt;TDelegate&gt;</code> class :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WeakEvent</span>&lt;TEventHandler&gt;
    {
        <span style="color:#66d9ef">private</span> List&lt;WeakDelegate&lt;TEventHandler&gt;&gt; _handlers;

        <span style="color:#66d9ef">public</span> WeakEvent()
        {
            _handlers = <span style="color:#66d9ef">new</span> List&lt;WeakDelegate&lt;TEventHandler&gt;&gt;();
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> AddHandler(TEventHandler handler)
        {
            Delegate d = (Delegate)(<span style="color:#66d9ef">object</span>)handler;
            _handlers.Add(<span style="color:#66d9ef">new</span> WeakDelegate&lt;TEventHandler&gt;(d));
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> RemoveHandler(TEventHandler handler)
        {
            <span style="color:#75715e">// also remove &#34;dead&#34; (garbage collected) handlers
</span><span style="color:#75715e"></span>            _handlers.RemoveAll(wd =&gt; !wd.IsAlive || wd.Equals(handler));
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Raise(<span style="color:#66d9ef">object</span> sender, EventArgs e)
        {
            <span style="color:#66d9ef">var</span> handlers = _handlers.ToArray();
            <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> weakDelegate <span style="color:#66d9ef">in</span> handlers)
            {
                <span style="color:#66d9ef">if</span> (weakDelegate.IsAlive)
                {
                    weakDelegate.Invoke(sender, e);
                }
                <span style="color:#66d9ef">else</span>
                {
                    _handlers.Remove(weakDelegate);
                }
            }
        }

        <span style="color:#66d9ef">protected</span> List&lt;WeakDelegate&lt;TEventHandler&gt;&gt; Handlers
        {
            <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> _handlers; }
        }
    }
</code></pre></div><p>This class automatically handles the removal of &ldquo;dead&rdquo; (garbage collected) handlers, and provides a <code>Raise</code> method to call the handlers. It can be used as follows :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">
        <span style="color:#66d9ef">private</span> WeakEvent&lt;EventHandler&gt; _myEvent = <span style="color:#66d9ef">new</span> WeakEvent&lt;EventHandler&gt;();
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">event</span> EventHandler MyEvent
        {
            <span style="color:#66d9ef">add</span> { _myEvent.AddHandler(<span style="color:#66d9ef">value</span>); }
            <span style="color:#66d9ef">remove</span> { _myEvent.RemoveHandler(<span style="color:#66d9ef">value</span>); }
        }

        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> OnMyEvent()
        {
            _myEvent.Raise(<span style="color:#66d9ef">this</span>, EventArgs.Empty);
        }
</code></pre></div><p>This is a bit longer to write than a &ldquo;regular&rdquo; event, but considering the benefits, it&rsquo;s very acceptable. Anyway, you can easily create a Visual Studio snippet to quickly create a weak event, with only 3 fields to fill in :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">
<span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34; ?&gt;</span>
<span style="color:#f92672">&lt;CodeSnippets</span>  <span style="color:#a6e22e">xmlns=</span><span style="color:#e6db74">&#34;http://schemas.microsoft.com/VisualStudio/2005/CodeSnippet&#34;</span><span style="color:#f92672">&gt;</span>
  <span style="color:#f92672">&lt;CodeSnippet</span> <span style="color:#a6e22e">Format=</span><span style="color:#e6db74">&#34;1.0.0&#34;</span><span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">&lt;Header&gt;</span>
      <span style="color:#f92672">&lt;Title&gt;</span>wevt<span style="color:#f92672">&lt;/Title&gt;</span>
      <span style="color:#f92672">&lt;Shortcut&gt;</span>wevt<span style="color:#f92672">&lt;/Shortcut&gt;</span>
      <span style="color:#f92672">&lt;Description&gt;</span>Code snippet for a weak event<span style="color:#f92672">&lt;/Description&gt;</span>
      <span style="color:#f92672">&lt;Author&gt;</span>Thomas Levesque<span style="color:#f92672">&lt;/Author&gt;</span>
      <span style="color:#f92672">&lt;SnippetTypes&gt;</span>
        <span style="color:#f92672">&lt;SnippetType&gt;</span>Expansion<span style="color:#f92672">&lt;/SnippetType&gt;</span>
      <span style="color:#f92672">&lt;/SnippetTypes&gt;</span>
    <span style="color:#f92672">&lt;/Header&gt;</span>
    <span style="color:#f92672">&lt;Snippet&gt;</span>
      <span style="color:#f92672">&lt;Declarations&gt;</span>
        <span style="color:#f92672">&lt;Literal&gt;</span>
          <span style="color:#f92672">&lt;ID&gt;</span>type<span style="color:#f92672">&lt;/ID&gt;</span>
          <span style="color:#f92672">&lt;ToolTip&gt;</span>Event type<span style="color:#f92672">&lt;/ToolTip&gt;</span>
          <span style="color:#f92672">&lt;Default&gt;</span>EventHandler<span style="color:#f92672">&lt;/Default&gt;</span>
        <span style="color:#f92672">&lt;/Literal&gt;</span>
        <span style="color:#f92672">&lt;Literal&gt;</span>
          <span style="color:#f92672">&lt;ID&gt;</span>event<span style="color:#f92672">&lt;/ID&gt;</span>
          <span style="color:#f92672">&lt;ToolTip&gt;</span>Event name<span style="color:#f92672">&lt;/ToolTip&gt;</span>
          <span style="color:#f92672">&lt;Default&gt;</span>MyEvent<span style="color:#f92672">&lt;/Default&gt;</span>
        <span style="color:#f92672">&lt;/Literal&gt;</span>
        <span style="color:#f92672">&lt;Literal&gt;</span>
          <span style="color:#f92672">&lt;ID&gt;</span>field<span style="color:#f92672">&lt;/ID&gt;</span>
          <span style="color:#f92672">&lt;ToolTip&gt;</span>Name of the field holding the registered handlers<span style="color:#f92672">&lt;/ToolTip&gt;</span>
          <span style="color:#f92672">&lt;Default&gt;</span>_myEvent<span style="color:#f92672">&lt;/Default&gt;</span>
        <span style="color:#f92672">&lt;/Literal&gt;</span>
      <span style="color:#f92672">&lt;/Declarations&gt;</span>
      <span style="color:#f92672">&lt;Code</span> <span style="color:#a6e22e">Language=</span><span style="color:#e6db74">&#34;csharp&#34;</span><span style="color:#f92672">&gt;</span>
        <span style="color:#75715e">&lt;![CDATA[private WeakEvent&lt;$type$&gt; $field$ = new WeakEvent&lt;EventHandler&gt;();
</span><span style="color:#75715e">        public event $type$ $event$
</span><span style="color:#75715e">        {
</span><span style="color:#75715e">            add { $field$.AddHandler(value); }
</span><span style="color:#75715e">            remove { $field$.RemoveHandler(value); }
</span><span style="color:#75715e">        }
</span><span style="color:#75715e">
</span><span style="color:#75715e">        protected virtual void On$event$()
</span><span style="color:#75715e">        {
</span><span style="color:#75715e">            $field$.Raise(this, EventArgs.Empty);
</span><span style="color:#75715e">        }$end$]]&gt;</span>
      <span style="color:#f92672">&lt;/Code&gt;</span>
    <span style="color:#f92672">&lt;/Snippet&gt;</span>
  <span style="color:#f92672">&lt;/CodeSnippet&gt;</span>
<span style="color:#f92672">&lt;/CodeSnippets&gt;</span>
</code></pre></div><p>This snippet gives the following result in Visual Studio :  <img src="screenshot_snippet_wevt.png" alt="Code snippet pour implémenter un WeakEvent"></p>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/c" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">C#</a>
   </li>
  
   <li class="list">
     <a href="/tags/code-snippet" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">code snippet</a>
   </li>
  
   <li class="list">
     <a href="/tags/weak-event" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">weak event</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/2010/02/21/automating-null-checks-with-linq-expressions/">Automating null checks with Linq expressions</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2009/06/12/c-parentchild-relationship-and-xml-serialization/">[C#] Parent/child relationship and XML serialization</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://blog2.thomaslevesque.net/" >
    &copy;  Thomas Levesque .NET Blog 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
