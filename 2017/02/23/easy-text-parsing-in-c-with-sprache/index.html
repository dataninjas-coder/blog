<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Easy text parsing in C# with Sprache | Thomas Levesque&#39;s .NET Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.69.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="Easy text parsing in C# with Sprache" />
<meta property="og:description" content="A few days ago, I discovered a little gem: Sprache. The name means &ldquo;language&rdquo; in German. It&rsquo;s a very elegant and easy to use library to create text parsers, using parser combinators, which are a very common technique in functional programming. The theorical concept may seem a bit scary, but as you&rsquo;ll see in a minute, Sprache makes it very simple.
Text parsing Parsing text is a common task, but it can be tedious and error-prone." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog2.thomaslevesque.net/2017/02/23/easy-text-parsing-in-c-with-sprache/" />
<meta property="article:published_time" content="2017-02-23T00:00:00+00:00" />
<meta property="article:modified_time" content="2017-02-23T00:00:00+00:00" />
<meta itemprop="name" content="Easy text parsing in C# with Sprache">
<meta itemprop="description" content="A few days ago, I discovered a little gem: Sprache. The name means &ldquo;language&rdquo; in German. It&rsquo;s a very elegant and easy to use library to create text parsers, using parser combinators, which are a very common technique in functional programming. The theorical concept may seem a bit scary, but as you&rsquo;ll see in a minute, Sprache makes it very simple.
Text parsing Parsing text is a common task, but it can be tedious and error-prone.">
<meta itemprop="datePublished" content="2017-02-23T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2017-02-23T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1790">



<meta itemprop="keywords" content="parser,parser combinator,parsing,sprache," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Easy text parsing in C# with Sprache"/>
<meta name="twitter:description" content="A few days ago, I discovered a little gem: Sprache. The name means &ldquo;language&rdquo; in German. It&rsquo;s a very elegant and easy to use library to create text parsers, using parser combinators, which are a very common technique in functional programming. The theorical concept may seem a bit scary, but as you&rsquo;ll see in a minute, Sprache makes it very simple.
Text parsing Parsing text is a common task, but it can be tedious and error-prone."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://blog2.thomaslevesque.net/" class="f3 fw2 hover-white no-underline white-90 dib">
      Thomas Levesque&#39;s .NET Blog
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="About page">
              About
            </a>
          </li>
          
        </ul>
      
      














    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://blog2.thomaslevesque.net/2017/02/23/easy-text-parsing-in-c-with-sprache/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://blog2.thomaslevesque.net/2017/02/23/easy-text-parsing-in-c-with-sprache/&amp;text=Easy%20text%20parsing%20in%20C#%20with%20Sprache" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog2.thomaslevesque.net/2017/02/23/easy-text-parsing-in-c-with-sprache/&amp;title=Easy%20text%20parsing%20in%20C#%20with%20Sprache" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>

      <h1 class="f1 athelas mt3 mb1">Easy text parsing in C# with Sprache</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2017-02-23T00:00:00Z">February 23, 2017</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>A few days ago, I discovered a little gem: <a href="https://github.com/sprache/sprache">Sprache</a>. The name means &ldquo;language&rdquo; in German. It&rsquo;s a very elegant and easy to use library to create text parsers, using <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinators</a>, which are a very common technique in functional programming. The theorical concept may seem a bit scary, but as you&rsquo;ll see in a minute, Sprache makes it very simple.</p>
<h2 id="text-parsing">Text parsing</h2>
<p>Parsing text is a common task, but it can be tedious and error-prone. There are plenty of ways to do it:</p>
<ul>
<li>manual parsing based on <code>Split</code>, <code>IndexOf</code>, <code>Substring</code> etc.</li>
<li>regular expressions</li>
<li>hand-built parser that scans the string for tokens</li>
<li>full blown parser generated with ANTLR or a similar tool</li>
<li>and probably many others&hellip;</li>
</ul>
<p>None of these options is very appealing. For simple cases, splitting the string or using a regex can be enough, but it doesn&rsquo;t scale to more complex grammars. Building a real parser by hand for non-trivial grammars is, well, non-trivial. ANTLR requires Java, a bit of knowledge, and it relies on code generation, which complicates the build process.</p>
<p>Fortunately, <a href="https://github.com/sprache/sprache">Sprache</a> offers a very nice alternative. It provides many predefined parsers and combinators that you can use to define a grammar. Let&rsquo;s walk through an example: parsing the challenge in the <code>WWW-Authenticate</code> header of an HTTP response (I recently had to write a parser by hand for this recently, and I wish I had known Sprache then).</p>
<h2 id="the-grammar">The grammar</h2>
<p>The <code>WWW-Authenticate</code> header is sent by an HTTP server as part of a 401 (Unauthorized) response to indicate how you should authenticate:</p>
<pre><code># Basic challenge
WWW-Authenticate: Basic realm=&quot;FooCorp&quot;

# OAuth 2.0 challenge after sending an expired token
WWW-Authenticate: Bearer realm=&quot;FooCorp&quot;, error=invalid_token, error_description=&quot;The access token has expired&quot;
</code></pre><p>What we want to parse is the &ldquo;challenge&rdquo;, i.e. the value of the header. So, we have an authentication scheme (<code>Basic</code>, <code>Bearer</code>), followed by one or more parameters (name-value pairs). This looks simple enough, we could probably just split by <code>','</code> then by <code>'='</code> to get the values&hellip; but the double quotes complicate things, since quoted strings could contain the <code>','</code> or <code>'='</code> characters. Also, the double quotes are optional if the parameter value is a single token, so we can&rsquo;t rely on the fact they will (or won&rsquo;t) be there. If we want to parse this reliably, we&rsquo;re going to have to look at the specs.</p>
<p>The <code>WWW-Authenticate</code> header is described in detail in <a href="https://tools.ietf.org/html/rfc2617">RFC-2617</a>. The grammar looks like this, in what the RFC calls &ldquo;augmented Backus-Naur Form&rdquo; (see <a href="https://tools.ietf.org/html/rfc2616#section-2.1">RFC 2616 §2.1</a>):</p>
<pre><code># from RFC-2617 (HTTP Basic and Digest authentication)

challenge      = auth-scheme 1*SP 1#auth-param
auth-scheme    = token
auth-param     = token &quot;=&quot; ( token | quoted-string )

# from RFC2616 (HTTP/1.1)

token          = 1*&lt;any CHAR except CTLs or separators&gt;
separators     = &quot;(&quot; | &quot;)&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;@&quot;
               | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &lt;&quot;&gt;
               | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;
               | &quot;{&quot; | &quot;}&quot; | SP | HT
quoted-string  = ( &lt;&quot;&gt; *(qdtext | quoted-pair ) &lt;&quot;&gt; )
qdtext         = &lt;any TEXT except &lt;&quot;&gt;&gt;
quoted-pair    = &quot;\&quot; CHAR
</code></pre><p>So, we have a few grammar rules, let&rsquo;s see how we can encode them in C# code with Sprache, and use them to parse a challenge.</p>
<h2 id="parsing-tokens">Parsing tokens</h2>
<p>Let&rsquo;s start with the most simple parts of the grammar: tokens. A token is declared as one or more of any characters that are not control chars or separators.</p>
<p>We&rsquo;ll define our rules in a <code>Grammar</code> class. Let&rsquo;s start by defining some character classes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Grammar</span>
{
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; SeparatorChar =
        Parse.Chars(<span style="color:#e6db74">&#34;()&lt;&gt;@,;:\\\&#34;/[]?={} \t&#34;</span>);

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; ControlChar =
        Parse.Char(Char.IsControl, <span style="color:#e6db74">&#34;Control character&#34;</span>);

}
</code></pre></div><ul>
<li>Each rule is declared as a <code>Parser&lt;T&gt;</code>; since these rules match single characters, they are of type <code>Parser&lt;char&gt;</code>.</li>
<li>The <code>Parse</code> class from Sprache exposes parser primitives and combinators.</li>
<li><code>Parse.Chars</code> matches any character from the specified string, we use it to specify the list of separator characters.</li>
<li>The overload of <code>Parse.Char</code> that we use here takes a predicate that will be called to check if the character matches, and a description of the character class. Here we just use <code>System.Char.IsControl</code> as the predicate to match control characters.</li>
</ul>
<p>Now, let&rsquo;s define a <code>TokenChar</code> character class to match characters that can be part of a token. As per the RFC, this can be any character not in the previous classes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; TokenChar =
        Parse.AnyChar
            .Except(SeparatorChar)
            .Except(ControlChar);
</code></pre></div><ul>
<li><code>Parse.AnyChar</code>, as the name implies, matches any character.</li>
<li><code>Except</code> specifies exceptions to the rule.</li>
</ul>
<p>Finally, a token is a sequence of one or more of these characters:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">string</span>&gt; Token =
        TokenChar.AtLeastOnce().Text();
</code></pre></div><ul>
<li>A token is a string, so the rule for a token is of type <code>Parser&lt;string&gt;</code>.</li>
<li><code>AtLeastOnce()</code> means one or more repetitions, and since <code>TokenChar</code> is a <code>Parser&lt;char&gt;</code>, it returns a <code>Parser&lt;IEnumerable&lt;char&gt;&gt;</code>.</li>
<li><code>Text()</code> combines the sequence of characters into a string, returning a <code>Parser&lt;string&gt;</code>.</li>
</ul>
<p>We&rsquo;re now able to parse a token. But it&rsquo;s just a small step, and we still have a lot to do&hellip;</p>
<h2 id="parsing-quoted-strings">Parsing quoted strings</h2>
<p>The grammar defines a quoted string as a sequence of:</p>
<ul>
<li>an opening double quote</li>
<li>any number of either
<ul>
<li>a &ldquo;qdtext&rdquo;, which is any character except a double quote</li>
<li>a &ldquo;quoted pair&rdquo;, which is any character preceded by a backslash (this is used to escape double quotes inside a string)</li>
</ul>
</li>
<li>a closing double quote</li>
</ul>
<p>Let&rsquo;s write the rules for &ldquo;qdtext&rdquo; and &ldquo;quoted pair&rdquo;:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; DoubleQuote = Parse.Char(<span style="color:#e6db74">&#39;&#34;&#39;</span>);
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; Backslash = Parse.Char(<span style="color:#e6db74">&#39;\\&#39;</span>);

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; QdText =
        Parse.AnyChar.Except(DoubleQuote);

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; QuotedPair =
        <span style="color:#66d9ef">from</span> _ <span style="color:#66d9ef">in</span> Backslash
        <span style="color:#66d9ef">from</span> c <span style="color:#66d9ef">in</span> Parse.AnyChar
        <span style="color:#66d9ef">select</span> c;
</code></pre></div><p>The <code>QdText</code> rule doesn&rsquo;t require much explanation, but <code>QuotedPair</code> is more interesting&hellip; As you can see, it looks like a Linq query: this is Sprache&rsquo;s way of specifying a sequence. This particular query means: <em>match a backslash (named <code>_</code> because we ignore it) followed by any character named <code>c</code>, and return just <code>c</code></em> (quoted pairs are not escape sequences in the same sense as in C, Java or C#, so <code>&quot;\n&quot;</code> isn&rsquo;t interpreted as &ldquo;new line&rdquo; but just as <code>&quot;n&quot;</code>).</p>
<p>We can now write the rule for a quoted string:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">string</span>&gt; QuotedString =
        <span style="color:#66d9ef">from</span> open <span style="color:#66d9ef">in</span> DoubleQuote
        <span style="color:#66d9ef">from</span> text <span style="color:#66d9ef">in</span> QuotedPair.Or(QdText).Many().Text()
        <span style="color:#66d9ef">from</span> close <span style="color:#66d9ef">in</span> DoubleQuote
        <span style="color:#66d9ef">select</span> text;
</code></pre></div><ul>
<li>the <code>Or</code> method indicates a choice between two parsers. <code>QuotedPair.Or(QdText)</code> will try to match a quoted pair, and if that fails, it will try to match a <code>QdText</code> instead.</li>
<li><code>Many()</code> indicates any number of repetition</li>
<li><code>Text()</code> combines the characters into a string</li>
</ul>
<p>We now have all the basic building blocks, so we can move on to higher level rules.</p>
<h3 id="parsing-challenge-parameters">Parsing challenge parameters</h3>
<p>A challenge is made of an auth scheme followed by one or more parameters. The auth scheme is trivial (it&rsquo;s just a token), so let&rsquo;s start by parsing the parameters.</p>
<p>Although there isn&rsquo;t a named rule for it in the grammar, let&rsquo;s define a rule for parameter values. The value can be either a token or a quoted string:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">string</span>&gt; ParameterValue =
        Token.Or(QuotedString);
</code></pre></div><p>Since a parameter is a composite element (name and value), let&rsquo;s define a class to represent it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parameter</span>
{
    <span style="color:#66d9ef">public</span> Parameter(<span style="color:#66d9ef">string</span> name, <span style="color:#66d9ef">string</span> <span style="color:#66d9ef">value</span>)
    {
        Name = name;
        Value = <span style="color:#66d9ef">value</span>;
    }
    
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name { <span style="color:#66d9ef">get</span>; }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Value { <span style="color:#66d9ef">get</span>; }
}
</code></pre></div><p>The <code>T</code> in <code>Parser&lt;T&gt;</code> isn&rsquo;t restricted to characters and strings, it can be any type. So the rule for parsing parameters will be of type <code>Parser&lt;Parameter&gt;</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; EqualSign = Parse.Char(<span style="color:#e6db74">&#39;=&#39;</span>);

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;Parameter&gt; Parameter =
        <span style="color:#66d9ef">from</span> name <span style="color:#66d9ef">in</span> Token
        <span style="color:#66d9ef">from</span> _ <span style="color:#66d9ef">in</span> EqualSign
        <span style="color:#66d9ef">from</span> <span style="color:#66d9ef">value</span> <span style="color:#66d9ef">in</span> ParameterValue
        <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">new</span> Parameter(name, <span style="color:#66d9ef">value</span>);
</code></pre></div><p>Here we match a token (the parameter name), followed by the <code>'='</code> sign, followed by a parameter value, and we combine the name and value into a <code>Parameter</code> instance.</p>
<p>Now let&rsquo;s parse a sequence of one or more parameters. Parameters are separated by commas (<code>','</code>), with optional leading and trailing whitespace (look for &ldquo;#rule&rdquo; in <a href="https://tools.ietf.org/html/rfc2616#section-2.1">RFC 2616 §2.1</a>). The grammar for lists allows several commas without items in between, e.g. &ldquo;item1 ,, item2,item3, ,item4&rdquo;, so the rule for the delimiter can be written like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; Comma = Parse.Char(<span style="color:#e6db74">&#39;,&#39;</span>);

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; ListDelimiter =
        <span style="color:#66d9ef">from</span> leading <span style="color:#66d9ef">in</span> Parse.WhiteSpace.Many()
        <span style="color:#66d9ef">from</span> c <span style="color:#66d9ef">in</span> Comma
        <span style="color:#66d9ef">from</span> trailing <span style="color:#66d9ef">in</span> Parse.WhiteSpace.Or(Comma).Many()
        <span style="color:#66d9ef">select</span> c;
</code></pre></div><p>We just match the first comma, the rest can be any number of commas or whitespace characters. We return the comma because we have to return something, but we won&rsquo;t actually use it.</p>
<p>We could now match the sequence of parameters like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;Parameter[]&gt; Parameters =
        <span style="color:#66d9ef">from</span> first <span style="color:#66d9ef">in</span> Parameter.Once()
        <span style="color:#66d9ef">from</span> others <span style="color:#66d9ef">in</span> (
            <span style="color:#66d9ef">from</span> _ <span style="color:#66d9ef">in</span> ListDelimiter
            <span style="color:#66d9ef">from</span> p <span style="color:#66d9ef">in</span> Parameter
            <span style="color:#66d9ef">select</span> p).Many()
        <span style="color:#66d9ef">select</span> first.Concat(others).ToArray();
</code></pre></div><p>But it&rsquo;s not very straightforward&hellip; fortunately Sprache provides an easier option with the <code>DelimitedBy</code> method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;Parameter[]&gt; Parameters =
        <span style="color:#66d9ef">from</span> p <span style="color:#66d9ef">in</span> Parameter.DelimitedBy(ListDelimiter)
        <span style="color:#66d9ef">select</span> p.ToArray();
</code></pre></div><h2 id="parsing-the-challenge">Parsing the challenge</h2>
<p>We&rsquo;re almost done. We now have everything we need to parse the whole challenge. Let&rsquo;s define a class to represent it first:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Challenge</span>
{
    <span style="color:#66d9ef">public</span> Challenge(<span style="color:#66d9ef">string</span> scheme, Parameter[] parameters)
    {
        Scheme = scheme;
        Parameters = parameters;
    }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Scheme { <span style="color:#66d9ef">get</span>; }
    <span style="color:#66d9ef">public</span> Parameter[] Parameters { <span style="color:#66d9ef">get</span>; }
}
</code></pre></div><p>And finally we can write the top-level rule:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;Challenge&gt; Challenge =
        <span style="color:#66d9ef">from</span> scheme <span style="color:#66d9ef">in</span> Token
        <span style="color:#66d9ef">from</span> _ <span style="color:#66d9ef">in</span> Parse.WhiteSpace.AtLeastOnce()
        <span style="color:#66d9ef">from</span> parameters <span style="color:#66d9ef">in</span> Parameters
        <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">new</span> Challenge(scheme, parameters);
</code></pre></div><p>Note that I made this rule public, unlike the others: it&rsquo;s the only one we need to expose.</p>
<h2 id="using-the-parser">Using the parser</h2>
<p>Our parser is done, now we just have to use it, which is pretty straightforward:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">void</span> ParseAndPrintChallenge(<span style="color:#66d9ef">string</span> input)
{
    <span style="color:#66d9ef">var</span> challenge = Grammar.Challenge.Parse(input);
    Console.WriteLine(<span style="color:#e6db74">$&#34;Scheme: {challenge.Scheme}&#34;</span>);
    Console.WriteLine(<span style="color:#e6db74">$&#34;Parameters:&#34;</span>);
    <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> p <span style="color:#66d9ef">in</span> challenge.Parameters)
    {
        Console.WriteLine(<span style="color:#e6db74">$&#34;- {p.Name} = {p.Value}&#34;</span>);
    }
}
</code></pre></div><p>With the OAuth 2.0 challenge example from earlier, this produces the following output:</p>
<pre><code>Scheme: Bearer
Parameters:
- realm = FooCorp
- error = invalid_token
- error_description = The access token has expired
</code></pre><p>If there&rsquo;s a syntax error in the input text, the <code>Parse</code> will throw a <code>ParseException</code> with a message describing where and why the parsing failed. For instance, if I remove the space between &ldquo;Bearer&rdquo; and &ldquo;realm&rdquo;, I get the following error:</p>
<blockquote>
<p>Parsing failure: unexpected &lsquo;=&rsquo;; expected whitespace (Line 1, Column 12); recently consumed: earerrealm</p>
</blockquote>
<p>You can find the full code for this article <a href="https://gist.github.com/thomaslevesque/d8ee28be1cf383a3f8aaf39cee776f92">here</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As you can see, Sprache makes it very simple to parse complex text. The code isn&rsquo;t particularly short, but it&rsquo;s completely declarative; there are no loops, no conditionals, no temporary variables, no state&hellip; This makes it very easy to understand, and it can easily be compared with the actual grammar definition to check its correctness. It also provides pretty good feedback in case of error, which is hard to accomplish with a hand-built parser.</p>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/parser" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">parser</a>
   </li>
  
   <li class="list">
     <a href="/tags/parser-combinator" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">parser combinator</a>
   </li>
  
   <li class="list">
     <a href="/tags/parsing" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">parsing</a>
   </li>
  
   <li class="list">
     <a href="/tags/sprache" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">sprache</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://blog2.thomaslevesque.net/" >
    &copy;  Thomas Levesque's .NET Blog 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
