<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Uploading data with HttpClient using a &#34;push&#34; model | Thomas Levesque .NET Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.69.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="Uploading data with HttpClient using a &#34;push&#34; model" />
<meta property="og:description" content="If you have used the HttpWebRequest class to upload data, you know that it uses a “push” model. What I mean is that you call the GetRequestStream method, which opens the connection if necessary, sends the headers, and returns a stream on which you can write directly.
.NET 4.5 introduced the HttpClient class as a new way to communicate over HTTP. It actually relies on HttpWebRequest under the hood, but offers a more convenient and fully asynchronous API." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog2.thomaslevesque.net/2013/11/30/uploading-data-with-httpclient-using-a-push-model/" />
<meta property="article:published_time" content="2013-11-30T21:47:09+00:00" />
<meta property="article:modified_time" content="2013-11-30T21:47:09+00:00" />
<meta itemprop="name" content="Uploading data with HttpClient using a &#34;push&#34; model">
<meta itemprop="description" content="If you have used the HttpWebRequest class to upload data, you know that it uses a “push” model. What I mean is that you call the GetRequestStream method, which opens the connection if necessary, sends the headers, and returns a stream on which you can write directly.
.NET 4.5 introduced the HttpClient class as a new way to communicate over HTTP. It actually relies on HttpWebRequest under the hood, but offers a more convenient and fully asynchronous API.">
<meta itemprop="datePublished" content="2013-11-30T21:47:09&#43;00:00" />
<meta itemprop="dateModified" content="2013-11-30T21:47:09&#43;00:00" />
<meta itemprop="wordCount" content="671">



<meta itemprop="keywords" content="HttpClient,HttpContent,JSON,ObjectContent,push,PushStreamContent," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Uploading data with HttpClient using a &#34;push&#34; model"/>
<meta name="twitter:description" content="If you have used the HttpWebRequest class to upload data, you know that it uses a “push” model. What I mean is that you call the GetRequestStream method, which opens the connection if necessary, sends the headers, and returns a stream on which you can write directly.
.NET 4.5 introduced the HttpClient class as a new way to communicate over HTTP. It actually relies on HttpWebRequest under the hood, but offers a more convenient and fully asynchronous API."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://blog2.thomaslevesque.net/" class="f3 fw2 hover-white no-underline white-90 dib">
      Thomas Levesque .NET Blog
    </a>
    <div class="flex-l items-center">
      

      
      














    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://blog2.thomaslevesque.net/2013/11/30/uploading-data-with-httpclient-using-a-push-model/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://blog2.thomaslevesque.net/2013/11/30/uploading-data-with-httpclient-using-a-push-model/&amp;text=Uploading%20data%20with%20HttpClient%20using%20a%20%22push%22%20model" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog2.thomaslevesque.net/2013/11/30/uploading-data-with-httpclient-using-a-push-model/&amp;title=Uploading%20data%20with%20HttpClient%20using%20a%20%22push%22%20model" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>

      <h1 class="f1 athelas mt3 mb1">Uploading data with HttpClient using a &#34;push&#34; model</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2013-11-30T21:47:09Z">November 30, 2013</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>If you have used the <code>HttpWebRequest</code> class to upload data, you know that it uses a “push” model. What I mean is that you call the <code>GetRequestStream</code> method, which opens the connection if necessary, sends the headers, and returns a stream on which you can write directly.</p>
<p>.NET 4.5 introduced the <code>HttpClient</code> class as a new way to communicate over HTTP. It actually relies on <code>HttpWebRequest</code> under the hood, but offers a more convenient and fully asynchronous API. <code>HttpClient</code> uses a different approach when it comes to uploading data: instead of writing manually to the request stream, you set the <code>Content</code> property of the <code>HttpRequestMessage</code> to an instance of a class derived from <code>HttpContent</code>. You can also pass the content directly to the <code>PostAsync</code> or <code>PutAsync</code> methods.</p>
<p>The .NET Framework provides a few built-in implementations of <code>HttpContent</code>, here are some of the most commonly used:</p>
<ul>
<li><code>ByteArrayContent</code>: represents in-memory raw binary content</li>
<li><code>StringContent</code>: represents text in a specific encoding (this is a specialization of <code>ByteArrayContent</code>)</li>
<li><code>StreamContent</code>: represents raw binary content in the form of a <code>Stream</code></li>
</ul>
<p>For instance, here’s how you would upload the content of a file:</p>
<pre><code>
async Task UploadFileAsync(Uri uri, string filename)
{
    using (var stream = File.OpenRead(filename))
    {
        var client = new HttpClient();
        var response = await client.PostAsync(uri, new StreamContent(stream));
        response.EnsureSuccessStatusCode();
    }
}
</code></pre><p>As you may have noticed, nowhere in this code do we write to the request stream explicitly: the content is <em>pulled</em> from the source stream.</p>
<p>This “pull” model is fine most of the time, but it has a drawback: it requires that the data to upload already exists in a form that can be sent directly to the server. This is not always practical, because sometimes you want to generate the request content “on the fly”. For instance, if you want to send an object serialized as JSON, with the “pull” approach you first need to serialize it in memory as a string or <code>MemoryStream</code>, then assign that to the request’s content:</p>
<pre><code>
async Task UploadJsonObjectAsync&lt;T&gt;(Uri uri, T data)
{
    var client = new HttpClient();
    string json = JsonConvert.SerializeObject(data);
    var response = await client.PostAsync(uri, new StringContent(json));
    response.EnsureSuccessStatusCode();
}
</code></pre><p>This is fine for small objects, but obviously not optimal for large object graphs…</p>
<p>So, how could we reverse this pull model to a push model? Well, it’s actually pretty simple: all you have to do is to create a class that inherits <code>HttpContent</code>, and override the <code>SerializeToStreamAsync</code> method to write to the request stream directly. Actually, I intended to blog about my own implementation, but then I did some research, and it turns out that Microsoft has already done the work: the <a href="https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client">Web API 2 Client</a> library provides a `PushStreamContent``` class that does exactly that. Basically, you just pass a delegate that defines what to do with the request stream. Here’s how it works:</p>
<pre><code>
async Task UploadJsonObjectAsync&lt;T&gt;(Uri uri, T data)
{
    var client = new HttpClient();
    var content = new PushStreamContent((stream, httpContent, transportContext) =&gt;
    {
        var serializer = new JsonSerializer();
        using (var writer = new StreamWriter(stream))
        {
            serializer.Serialize(writer, data);
        }
    });
    var response = await client.PostAsync(uri, content);
    response.EnsureSuccessStatusCode();
}
</code></pre><p>Note that the <code>PushStreamContent</code> class also provides a constructor overload that accepts an asynchronous delegate, if you want to write to the stream asynchronously.</p>
<p>Actually, for this specific use case, the Web API 2 Client library provides a less convoluted approach: the <code>ObjectContent</code> class. You just pass it the object to send and a <code>MediaTypeFormatter</code>, and it takes care of serializing the object to the request stream:</p>
<pre><code>
async Task UploadJsonObjectAsync&lt;T&gt;(Uri uri, T data)
{
    var client = new HttpClient();
    var content = new ObjectContent&lt;T&gt;(data, new JsonMediaTypeFormatter());
    var response = await client.PostAsync(uri, content);
    response.EnsureSuccessStatusCode();
}
</code></pre><p>By default, the <code>JsonMediaTypeFormatter</code> class uses <a href="http://james.newtonking.com/json">Json.NET</a> as its JSON serializer, but there is an option to use <code>DataContractJsonSerializer</code> instead.</p>
<p>Note that if you need to read an object from the response content, this is even easier: just use the <a href="http://msdn.microsoft.com/en-us/library/system.net.http.httpcontentextensions.readasasync%28v=vs.118%29.aspx"><code>ReadAsAsync&lt;T&gt;</code></a> extension method (also in the Web API 2 Client library). So as you can see, <code>HttpClient</code> makes it <em>very</em> easy to consume REST APIs.</p>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/httpclient" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">HttpClient</a>
   </li>
  
   <li class="list">
     <a href="/tags/httpcontent" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">HttpContent</a>
   </li>
  
   <li class="list">
     <a href="/tags/json" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">JSON</a>
   </li>
  
   <li class="list">
     <a href="/tags/objectcontent" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">ObjectContent</a>
   </li>
  
   <li class="list">
     <a href="/tags/push" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">push</a>
   </li>
  
   <li class="list">
     <a href="/tags/pushstreamcontent" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">PushStreamContent</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://blog2.thomaslevesque.net/" >
    &copy;  Thomas Levesque .NET Blog 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
