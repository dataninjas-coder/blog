<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ASP.NET Core on Thomas Levesque .NET Blog</title>
    <link>https://blog2.thomaslevesque.net/categories/asp.net-core/</link>
    <description>Recent content in ASP.NET Core on Thomas Levesque .NET Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 Mar 2019 06:16:15 +0000</lastBuildDate>
    
	<atom:link href="https://blog2.thomaslevesque.net/categories/asp.net-core/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Scaling out ASP.NET Core SignalR using Azure Service Bus</title>
      <link>https://blog2.thomaslevesque.net/2019/03/18/scaling-out-asp-net-core-signalr-using-azure-service-bus/</link>
      <pubDate>Mon, 18 Mar 2019 06:16:15 +0000</pubDate>
      
      <guid>https://blog2.thomaslevesque.net/2019/03/18/scaling-out-asp-net-core-signalr-using-azure-service-bus/</guid>
      <description>ASP.NET Core SignalR is a super easy way to establish two-way communication between an ASP.NET Core app and its clients, using WebSockets, Server-Sent Events, or long polling, depending on the client&amp;rsquo;s capabilities. For instance, it can be used to send a notification to all connected clients. However, if you scale out your application to multiple server instances, it no longer works out of the box: only the clients connected to the instance that sent the notification will receive it.</description>
    </item>
    
    <item>
      <title>Google&#43; shutdown: fixing Google authentication in ASP.NET Core</title>
      <link>https://blog2.thomaslevesque.net/2019/01/10/google-shutdown-fixing-google-authentication-in-asp-net-core/</link>
      <pubDate>Thu, 10 Jan 2019 13:15:34 +0000</pubDate>
      
      <guid>https://blog2.thomaslevesque.net/2019/01/10/google-shutdown-fixing-google-authentication-in-asp-net-core/</guid>
      <description>A few months ago, Google decided to shutdown Google+, due to multiple data leaks. More recently, they announced that the Google+ APIs will be shutdown on March 7, 2019, which is pretty soon! In fact, calls to these APIs might start to fail as soon as January 28, which is less than 3 weeks from now. You might think that it doesn&amp;rsquo;t affect you as a developer; but if you&amp;rsquo;re using Google authentication in an ASP.</description>
    </item>
    
    <item>
      <title>Multitenant Azure AD issuer validation in ASP.NET Core</title>
      <link>https://blog2.thomaslevesque.net/2018/12/24/multitenant-azure-ad-issuer-validation-in-asp-net-core/</link>
      <pubDate>Mon, 24 Dec 2018 13:54:43 +0000</pubDate>
      
      <guid>https://blog2.thomaslevesque.net/2018/12/24/multitenant-azure-ad-issuer-validation-in-asp-net-core/</guid>
      <description>If you use Azure AD authentication and want to allow users from any tenant to connect to your ASP.NET Core application, you need to configure the Azure AD app as multi-tenant, and use a &amp;ldquo;wildcard&amp;rdquo; tenant id such as organizations or common in the authority URL:
openIdConnectOptions.Authority = &amp;#34;https://login.microsoftonline.com/organizations/v2.0&amp;#34;; The problem when you do that is that with the default configuration, the token validation will fail because the issuer in the token won&amp;rsquo;t match the issuer specified in the OpenID metadata.</description>
    </item>
    
    <item>
      <title>Asynchronous initialization in ASP.NET Core, revisited</title>
      <link>https://blog2.thomaslevesque.net/2018/09/25/asynchronous-initialization-in-asp-net-core-revisited/</link>
      <pubDate>Tue, 25 Sep 2018 21:43:22 +0000</pubDate>
      
      <guid>https://blog2.thomaslevesque.net/2018/09/25/asynchronous-initialization-in-asp-net-core-revisited/</guid>
      <description>Initialization in ASP.NET Core is a bit awkward. There are well defined places for registering services (the Startup.ConfigureServices method) and for building the middleware pipeline (the Startup.Configure method), but not for performing other initialization steps (e.g. pre-loading data, seeding a database, etc.).
Using a middleware: not such a good idea Two months ago I published a blog post about asynchronous initialization of an ASP.NET Core app using a custom middleware. At the time I was rather pleased with my solution, but a comment from Frantisek made me realize it wasn&amp;rsquo;t such a good approach.</description>
    </item>
    
    <item>
      <title>Handling multipart requests with JSON and file uploads in ASP.NET Core</title>
      <link>https://blog2.thomaslevesque.net/2018/09/04/handling-multipart-requests-with-json-and-file-uploads-in-asp-net-core/</link>
      <pubDate>Tue, 04 Sep 2018 09:56:23 +0000</pubDate>
      
      <guid>https://blog2.thomaslevesque.net/2018/09/04/handling-multipart-requests-with-json-and-file-uploads-in-asp-net-core/</guid>
      <description>Suppose we&amp;rsquo;re writing an API for a blog. Our &amp;ldquo;create post&amp;rdquo; endpoint should receive the title, body, tags and an image to display at the top of the post. This raises a question: how do we send the image? There are at least 3 options:
 Embed the image bytes as base64 in the JSON payload, e.g.  { &amp;#34;title&amp;#34;: &amp;#34;My first blog post&amp;#34;, &amp;#34;body&amp;#34;: &amp;#34;This is going to be the best blog EVER!</description>
    </item>
    
    <item>
      <title>Asynchronous initialization in ASP.NET Core with custom middleware</title>
      <link>https://blog2.thomaslevesque.net/2018/07/20/asynchronous-initialization-in-asp-net-core-with-custom-middleware/</link>
      <pubDate>Fri, 20 Jul 2018 15:46:31 +0000</pubDate>
      
      <guid>https://blog2.thomaslevesque.net/2018/07/20/asynchronous-initialization-in-asp-net-core-with-custom-middleware/</guid>
      <description>Update: I no longer recommend the approach described in this post. I propose a better solution here: Asynchronous initialization in ASP.NET Core, revisited.
Sometimes you need to perform some initialization steps when your web application starts. However, putting such code in the Startup.Configure method is generally not a good idea, because:
 There&amp;rsquo;s no current scope in the Configure method, so you can&amp;rsquo;t use services registered with &amp;ldquo;scoped&amp;rdquo; lifetime (this would throw an InvalidOperationException: Cannot resolve scoped service &amp;lsquo;MyApp.</description>
    </item>
    
  </channel>
</rss>