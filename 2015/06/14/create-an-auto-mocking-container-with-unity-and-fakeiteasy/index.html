<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Create an auto-mocking container with Unity and FakeItEasy - Thomas Levesque&#39;s .NET Blog</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	
	
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-31621259-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Thomas Levesque&#39;s .NET Blog" rel="home">
				<div class="logo__title">Thomas Levesque&#39;s .NET Blog</div>
				
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Create an auto-mocking container with Unity and FakeItEasy</h1>
			
		</header><div class="content post__content clearfix">
			<p>Unit testing can be tedious sometimes, especially when testing classes that have complex dependencies. Fortunately, some tools make it somewhat easier. I’ve been using <a href="https://github.com/FakeItEasy/FakeItEasy">FakeItEasy</a> a lot recently; it’s a very easy to use mocking framework for .NET. It has a very lean and simple API based on generics and lambda expressions, and is a real pleasure to work with. It came as a breath of fresh air compared to the old RhinoMocks I had been using before.</p>
<p>But as nice as FakeItEasy is, the process of registering all the fake dependencies for the class you are testing is still a bit tedious. Wouldn’t it be nice if the IoC container could automatically create the fakes on demand ? So this code:</p>
<pre><code>var container = new UnityContainer();

// Setup dependencies
var fooProvider = A.Fake&lt;IFooProvider&gt;();
container.RegisterInstance(fooProvider);
var barService = A.Fake&lt;IBarService&gt;();
container.RegisterInstance(barService);
var bazManager = A.Fake&lt;IBazManager&gt;();
container.RegisterInstance(bazManager);

var sut = container.Resolve&lt;SystemUnderTest&gt;();
</code></pre><p>Could be reduced to this:</p>
<pre><code>var container = new UnityContainer();

// This will cause the container to provide fakes for all dependencies
container.AddNewExtension&lt;AutoFakeExtension&gt;();

var sut = container.Resolve&lt;SystemUnderTest&gt;();
</code></pre><p>Well, it’s actually pretty easy to do with Unity. Unity is usually not considered the “cool kid” in the small world of IoC containers, but it’s well supported, easy to use, and extensible. I came up with the following extension to enable the above scenario:</p>
<pre><code>public class AutoFakeExtension : UnityContainerExtension
{
    protected override void Initialize()
    {
        Context.Strategies.AddNew&lt;AutoFakeBuilderStrategy&gt;(UnityBuildStage.PreCreation);
    }
    
    private class AutoFakeBuilderStrategy : BuilderStrategy
    {
        private static readonly MethodInfo _fakeGenericDefinition;
    
        static AutoFakeBuilderStrategy()
        {
            _fakeGenericDefinition = typeof(A).GetMethod(&quot;Fake&quot;, Type.EmptyTypes);
        }
        
        public override void PreBuildUp(IBuilderContext context)
        {
            if (context.Existing == null)
            {
                var type = context.BuildKey.Type;
                if (type.IsInterface || type.IsAbstract)
                {
                    var fakeMethod = _fakeGenericDefinition.MakeGenericMethod(type);
                    var fake = fakeMethod.Invoke(null, new object[0]);
                    context.PersistentPolicies.Set&lt;ILifetimePolicy&gt;(new ContainerControlledLifetimeManager(), context.BuildKey);
                    context.Existing = fake;
                    context.BuildComplete = true;
                }
            }
            base.PreBuildUp(context);
        }
    }
}
</code></pre><p>A few comments on this code:</p>
<ul>
<li>The logic is a bit crude (it generates fakes only for interfaces and abstract classes), but can easily be adjusted if necessary.</li>
<li>The ugly reflection hack is due to the fact that FakeItEasy doesn’t have an non-generic overload of <code>A.Fake</code> that accepts a <code>Type</code> as a parameter. Well, nobody’s perfect…</li>
<li>The lifetime is set to “container controlled”, because if you need to configure method calls, you will need to access the same instance that is injected into the system under test:</li>
</ul>
<pre><code>var fooProvider = container.Resolve&lt;IFooProvider&gt;();
A.CallTo(() =&gt; fooProvider.GetFoo(42)).Returns(new Foo { Id = 42, Name = “test” });
</code></pre><p>Note that if you register a dependency explicitly, it will take precedence and no fake will be created. So you can use this extension and still be able to manually specify a dependency:</p>
<pre><code>var container = new UnityContainer();
container.AddNewExtension&lt;AutoFakeExtension&gt;();
container.RegisterType&lt;IFooProvider, TestFooProvider&gt;();
var sut = container.Resolve&lt;SystemUnderTest&gt;();
</code></pre><p>Of course, this extension could easily be modified to use a different mocking framework. I guess the same principle could be applied to other IoC containers as well, as long as they have suitable extension points.</p>
<h3 id="what-about-autofixture">What about AutoFixture?</h3>
<p>Before you ask: yes, I know about <a href="https://github.com/AutoFixture/AutoFixture">AutoFixture</a>. It’s a pretty good library, and I actually tried to use it as well, with some success. The resulting code is very similar to the examples above. The main reason why I didn’t keep using it is that AutoFixture is not really an IoC container (though it does some of the things an IoC container does), and I prefer to use the same IoC mechanism in my unit tests and in the actual application. Also, I’m not very comfortable with the way it handles properties when creating an instance of the SUT. By default, it sets all public writable properties to dummy instances of their type; this is fine if those properties are used for dependency injection, but IMO it doesn’t make sense for other properties. I know I can suppress this behavior for specific properties, but I have to do it manually on a case by case basis; it doesn’t take IoC container specific attributes like <code>[Dependency]</code> into account. So eventually I found it easier to use my custom Unity extension.</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/c/" rel="tag">C#</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/dependency-injection/" rel="tag">dependency injection</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/fakeiteasy/" rel="tag">fakeiteasy</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/mocking/" rel="tag">mocking</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/unit-testing/" rel="tag">unit testing</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/unity/" rel="tag">unity</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>





			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 Thomas Levesque&#39;s .NET Blog.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>