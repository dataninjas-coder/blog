<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Explicitly switch to the UI thread in an async method | Thomas Levesque&#39;s .NET Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.69.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="Explicitly switch to the UI thread in an async method" />
<meta property="og:description" content="Async code is a great way to keep your app’s UI responsive. You can start an async operation from the UI thread, await it without blocking the UI thread, and naturally resume on the UI thread when it’s done. This is a very powerful feature, and most of the time you don’t even need to think about it; it “just works”. However, this works only if the async operation is started from a thread that has a synchronization context (such as the UI thread in Windows Forms, WPF or WinRT)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog2.thomaslevesque.net/2015/11/11/explicitly-switch-to-the-ui-thread-in-an-async-method/" />
<meta property="article:published_time" content="2015-11-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2015-11-11T00:00:00+00:00" />
<meta itemprop="name" content="Explicitly switch to the UI thread in an async method">
<meta itemprop="description" content="Async code is a great way to keep your app’s UI responsive. You can start an async operation from the UI thread, await it without blocking the UI thread, and naturally resume on the UI thread when it’s done. This is a very powerful feature, and most of the time you don’t even need to think about it; it “just works”. However, this works only if the async operation is started from a thread that has a synchronization context (such as the UI thread in Windows Forms, WPF or WinRT).">
<meta itemprop="datePublished" content="2015-11-11T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2015-11-11T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="765">



<meta itemprop="keywords" content="async,await,C#,synchronization context,UI," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Explicitly switch to the UI thread in an async method"/>
<meta name="twitter:description" content="Async code is a great way to keep your app’s UI responsive. You can start an async operation from the UI thread, await it without blocking the UI thread, and naturally resume on the UI thread when it’s done. This is a very powerful feature, and most of the time you don’t even need to think about it; it “just works”. However, this works only if the async operation is started from a thread that has a synchronization context (such as the UI thread in Windows Forms, WPF or WinRT)."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://blog2.thomaslevesque.net/" class="f3 fw2 hover-white no-underline white-90 dib">
      Thomas Levesque&#39;s .NET Blog
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="About page">
              About
            </a>
          </li>
          
        </ul>
      
      














    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://blog2.thomaslevesque.net/2015/11/11/explicitly-switch-to-the-ui-thread-in-an-async-method/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://blog2.thomaslevesque.net/2015/11/11/explicitly-switch-to-the-ui-thread-in-an-async-method/&amp;text=Explicitly%20switch%20to%20the%20UI%20thread%20in%20an%20async%20method" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog2.thomaslevesque.net/2015/11/11/explicitly-switch-to-the-ui-thread-in-an-async-method/&amp;title=Explicitly%20switch%20to%20the%20UI%20thread%20in%20an%20async%20method" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>

      <h1 class="f1 athelas mt3 mb1">Explicitly switch to the UI thread in an async method</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2015-11-11T00:00:00Z">November 11, 2015</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>Async code is a great way to keep your app’s UI responsive. You can start an async operation from the UI thread, <code>await</code> it without blocking the UI thread, and naturally resume on the UI thread when it’s done. This is a very powerful feature, and most of the time you don’t even need to think about it; it “just works”. However, this works only if the async operation is started from a thread that has a <a href="https://msdn.microsoft.com/en-us/library/system.threading.synchronizationcontext.aspx">synchronization context</a> (such as the UI thread in Windows Forms, WPF or WinRT). If you don’t have a sync context when the async operation starts, or if resuming on the sync context is explicitly disabled with <code>ConfigureAwait(false)</code>, then the method resumes on a thread pool thread after the <code>await</code>, and there is no obvious way to get back to the UI thread.</p>
<p>For instance, let’s assume you want to do something like this:</p>
<pre><code>public async void btnStart_Click(object sender, RoutedEventArgs e)
{
    lblStatus.Text = &quot;Working...&quot;;
    
    // non blocking call
    var data = await GetDataFromRemoteServerAsync().ConfigureAwait(false);
    // blocking call, but runs on a worker thread
    DoSomeCpuBoundWorkWithTheData(data);
    
    // Oops, not on the UI thread!
    lblStatus.Text = &quot;Done&quot;;
}
</code></pre><p>This method starts an async operation to retrieve some data, and doesn’t resume on the UI thread, because it has some work to do in the background. When it’s done, it tries to update the UI, but since it’s not on the UI thread, it fails. This is a well known issue, and there are several workarounds. The most obvious one is to explicitly marshall the action to the dispatcher thread:</p>
<pre><code>Dispatcher.Invoke(new Action(() =&gt; lblStatus.Text = &quot;Done&quot;));
</code></pre><p>But it’s not very elegant and readable. A better way to do it is simply to extract the part of the method that does the actual work to another method:</p>
<pre><code>public async void btnStart_Click(object sender, RoutedEventArgs e)
{
    lblStatus.Text = &quot;Working...&quot;;
    await DoSomeWorkAsync();
    lblStatus.Text = &quot;Done&quot;;
}

private async Task DoSomeWorkAsync()
{
    // non blocking call
    var data = await GetDataFromRemoteServerAsync().ConfigureAwait(false);
    // blocking call, but runs on a worker thread
    DoSomeCpuBoundWorkWithTheData(data);
}
</code></pre><p>It takes advantage of the normal behavior of <code>await</code>, which is to resume on the captured sync context if it was available.</p>
<p>However, there might be some cases where it’s not practical to split the method like this. Or perhaps you want to switch to the UI thread in a method that didn’t start on the UI thread. Of course, you can use <code>Dispatcher.Invoke</code>, but it doesn’t look very nice with all those lambda expressions. What would be nice would be to be able to write something like this:</p>
<pre><code>await syncContext;
</code></pre><p>Well, it’s actually pretty simple to do: we just need to create a custom awaiter. The <code>async</code>/<code>await</code> feature is pattern-based; for something to be “awaitable”, it must:</p>
<ul>
<li>have a <code>GetAwaiter()</code>method (which can be an extension method), which returns an object that:
<ul>
<li>implements the <code>INotifyCompletion</code> interface</li>
<li>has an <code>IsCompleted</code> boolean property</li>
<li>has a <code>GetResult()</code> method that synchronously returns the result (or void if there is no result)</li>
</ul>
</li>
</ul>
<p>So, we need to create an awaiter that captures a synchronization context, and causes the awaiting method to resume on this synchronization context. Here’s how it looks like:</p>
<pre><code>public struct SynchronizationContextAwaiter : INotifyCompletion
{
    private static readonly SendOrPostCallback _postCallback = state =&gt; ((Action)state)();

    private readonly SynchronizationContext _context;
    public SynchronizationContextAwaiter(SynchronizationContext context)
    {
        _context = context;
    }

    public bool IsCompleted =&gt; _context == SynchronizationContext.Current;

    public void OnCompleted(Action continuation) =&gt; _context.Post(_postCallback, continuation);

    public void GetResult() { }
}
</code></pre><ul>
<li>The constructor takes the synchronization context that the continuation needs to resume on.</li>
<li>The <code>IsCompleted</code> property returns true only if we’re already on this synchronization context.</li>
<li><code>OnCompleted</code> is called only if <code>IsCompleted</code> was false. It accepts a “continuation”, i.e. that code that must be executed when the operation completes. In an async method, the continuation is just the code that is after the awaited call. Since we want that continuation to run on the UI thread, we just post it to the sync context.</li>
<li><code>GetResult()</code> doesn’t need to do anything; it will just be called as part of the continuation.</li>
</ul>
<p>Now that we have this awaiter, we just need to create a <code>GetAwaiter</code> extension method for the synchronization context that returns this awaiter:</p>
<pre><code>public static SynchronizationContextAwaiter GetAwaiter(this SynchronizationContext context)
{
    return new SynchronizationContextAwaiter(context);
}
</code></pre><p>And we’re done!</p>
<p>The original method can now be rewritten like this:</p>
<pre><code>public async void btnStart_Click(object sender, RoutedEventArgs e)
{
    var syncContext = SynchronizationContext.Current;
    lblStatus.Text = &quot;Working...&quot;;
    
    // non blocking call
    var data = await GetDataFromRemoteServerAsync().ConfigureAwait(false);
    // blocking call, but runs on a worker thread
    DoSomeCpuBoundWorkWithTheData(data);
    
    // switch back to the UI thread
    await syncContext;
    lblStatus.Text = &quot;Done&quot;;
}
</code></pre><ul class="pa0">
  
   <li class="list">
     <a href="/tags/async" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">async</a>
   </li>
  
   <li class="list">
     <a href="/tags/await" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">await</a>
   </li>
  
   <li class="list">
     <a href="/tags/c" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">C#</a>
   </li>
  
   <li class="list">
     <a href="/tags/synchronization-context" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">synchronization context</a>
   </li>
  
   <li class="list">
     <a href="/tags/ui" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">UI</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/2014/11/04/passing-parameters-by-reference-to-an-asynchronous-method/">Passing parameters by reference to an asynchronous method</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/04/async-and-cancellation-support-for-wait-handles/">Async and cancellation support for wait handles</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/02/01/async-unit-tests-with-nunit/">Async unit tests with NUnit</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/09/05/wpf-prevent-the-user-from-pasting-an-image-in-a-richtextbox/">[WPF] Prevent the user from pasting an image in a RichTextBox</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/07/30/c-puzzle-2/">C# Puzzle 2</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/28/how-to-retrieve-dates-as-utc-in-sqlite/">How to retrieve dates as UTC in SQLite</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/14/create-an-auto-mocking-container-with-unity-and-fakeiteasy/">Create an auto-mocking container with Unity and FakeItEasy</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/03/10/c-puzzle-1/">C# Puzzle 1</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2014/12/07/optimize-toarray-and-tolist-by-providing-the-number-of-elements/">Optimize ToArray and ToList by providing the number of elements</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2014/11/23/easily-convert-file-sizes-to-human-readable-form/">Easily convert file sizes to human-readable form</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2014/11/02/easy-unit-testing-of-null-argument-validation/">Easy unit testing of null argument validation</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2013/11/04/showing-result-suggestions-in-a-winrt-searchbox-bug-regarding-the-image/">Showing result suggestions in a WinRT SearchBox: bug regarding the image</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2013/04/21/detecting-dependency-property-changes-in-winrt/">Detecting dependency property changes in WinRT</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2011/09/02/tail-recursion-in-c/">Tail recursion in C#</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2010/05/17/c-a-simple-implementation-of-the-weakevent-pattern/">[C#] A simple implementation of the WeakEvent pattern</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://blog2.thomaslevesque.net/" >
    &copy;  Thomas Levesque's .NET Blog 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
