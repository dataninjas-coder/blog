<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Understanding the ASP.NET Core middleware pipeline - Thomas Levesque&#39;s .NET Blog</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	
	
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-31621259-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Thomas Levesque&#39;s .NET Blog" rel="home">
				<div class="logo__title">Thomas Levesque&#39;s .NET Blog</div>
				
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Understanding the ASP.NET Core middleware pipeline</h1>
			
		</header><div class="content post__content clearfix">
			<h2 id="middlewhat">Middlewhat?</h2>
<p>The ASP.NET Core architecture features a system of <strong>middleware</strong>, which are pieces of code that handle requests and responses. Middleware are chained to each other to form a <strong>pipeline</strong>. Incoming requests are passed through the pipeline, where each middleware has a chance to do something with them before passing them to the next middleware. Outgoing responses are also passed through the pipeline, in reverse order. If this sounds very abstract, the following schema from the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware">official ASP.NET Core documentation</a> should help you understand:</p>
<p><img src="request-delegate-pipeline.png" alt="Middleware pipeline"></p>
<p>Middleware can do all sort of things, such as handling authentication, errors, static files, etc&hellip; MVC in ASP.NET Core is also implemented as a middleware.</p>
<h2 id="configuring-the-pipeline">Configuring the pipeline</h2>
<p>You typically configure the ASP.NET pipeline in the <code>Configure</code> method of your <code>Startup</code> class, by calling <code>Use*</code> methods on the <code>IApplicationBuilder</code>. Here&rsquo;s an example straight from the docs:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Configure(IApplicationBuilder app)
{
    app.UseExceptionHandler(<span style="color:#e6db74">&#34;/Home/Error&#34;</span>);
    app.UseStaticFiles();
    app.UseAuthentication();
    app.UseMvcWithDefaultRoute();
}
</code></pre></div><p>Each <code>Use*</code> method adds a middleware to the pipeline. The order in which they&rsquo;re added determines the order in which requests will traverse them. So an incoming request will first traverse the exception handler middleware, then the static files middleware, then the authentication middleware, and will eventually be handled by the MVC middleware.</p>
<p>The <code>Use*</code> methods in this example are actually just &ldquo;shortcuts&rdquo; to make it easier to build the pipeline. Behind the scenes, they all end up using (directly or indirectly) these low-level primitives: <code>Use</code> and <code>Run</code>. Both add a middleware to the pipeline, the difference is that <code>Run</code> adds a <em>terminal</em> middleware, i.e. a middleware that is the last in the pipeline.</p>
<h2 id="a-basic-pipeline-with-no-branches">A basic pipeline with no branches</h2>
<p>Let&rsquo;s look at a simple example, using only the <code>Use</code> and <code>Run</code> primitives:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Configure(IApplicationBuilder app)
{
    <span style="color:#75715e">// Middleware A
</span><span style="color:#75715e"></span>    app.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;A (before)&#34;</span>);
        <span style="color:#66d9ef">await</span> next();
        Console.WriteLine(<span style="color:#e6db74">&#34;A (after)&#34;</span>);
    });

    <span style="color:#75715e">// Middleware B
</span><span style="color:#75715e"></span>    app.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;B (before)&#34;</span>);
        <span style="color:#66d9ef">await</span> next();
        Console.WriteLine(<span style="color:#e6db74">&#34;B (after)&#34;</span>);
    });

    <span style="color:#75715e">// Middleware C (terminal)
</span><span style="color:#75715e"></span>    app.Run(<span style="color:#66d9ef">async</span> context =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;C&#34;</span>);
        <span style="color:#66d9ef">await</span> context.Response.WriteAsync(<span style="color:#e6db74">&#34;Hello world&#34;</span>);
    });
}
</code></pre></div><p>Here, each middleware is defined inline as an anonymous method; they could also be defined as full-blown classes, but for this example I picked the more concise option. Non-terminal middleware take two arguments: the <code>HttpContext</code> and a delegate to call the next middleware. Terminal middleware only take the <code>HttpContext</code>. Here we have two middleware A and B that just log to the console, and a terminal middleware C which writes the response. Here&rsquo;s the console output when we send a request to our app:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A (before)
B (before)
C
B (after)
A (after)
</code></pre></div><p>We can see that each middleware was traversed in the order in which it was added, then traversed again in reverse order. The pipeline can be represented like this:</p>
<p><img src="basic-pipeline.png" alt="Basic pipeline"></p>
<h2 id="short-circuiting-middleware">Short-circuiting middleware</h2>
<p>A middleware doesn&rsquo;t necessarily have to call the next middleware. For instance, if the static files middleware can handle a request, it doesn&rsquo;t need to pass it down to the rest of the pipeline, it can respond immediately. This behavior is called short-circuiting the pipeline.</p>
<p>In the previous example, if we comment out the call to <code>next()</code> in middleware B, we get the following output:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A (before)
B (before)
B (after)
A (after)
</code></pre></div><p>As you can see, middleware C is never invoked. The pipeline now looks like this:</p>
<p><img src="short-circuit.png" alt="Short-circuited pipeline"></p>
<h2 id="branching-the-pipeline">Branching the pipeline</h2>
<p>In the previous examples, there was only one &ldquo;branch&rdquo; in the pipeline: the middleware coming after A was always B, and the middleware coming after B was always C. But it doesn&rsquo;t have to be that way. You might want a given request to be processed by a completely different pipeline, based on the path or anything else.</p>
<p>There are two types of branches: branches that rejoin the main pipeline, and branches that don&rsquo;t.</p>
<h3 id="making-a-non-rejoining-branch">Making a non-rejoining branch</h3>
<p>This can be done using the <code>Map</code> or <code>MapWhen</code> method. <code>Map</code> lets you specify a branch based on the request path. <code>MapWhen</code> gives you more control: you can specify a predicate on the <code>HttpContext</code> to decide whether to branch or not. Let&rsquo;s look at a simple example using <code>Map</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Configure(IApplicationBuilder app)
{
    app.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;A (before)&#34;</span>);
        <span style="color:#66d9ef">await</span> next();
        Console.WriteLine(<span style="color:#e6db74">&#34;A (after)&#34;</span>);
    });

    app.Map(
        <span style="color:#66d9ef">new</span> PathString(<span style="color:#e6db74">&#34;/foo&#34;</span>),
        a =&gt; a.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
        {
            Console.WriteLine(<span style="color:#e6db74">&#34;B (before)&#34;</span>);
            <span style="color:#66d9ef">await</span> next();
            Console.WriteLine(<span style="color:#e6db74">&#34;B (after)&#34;</span>);
        }));

    app.Run(<span style="color:#66d9ef">async</span> context =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;C&#34;</span>);
        <span style="color:#66d9ef">await</span> context.Response.WriteAsync(<span style="color:#e6db74">&#34;Hello world&#34;</span>);
    });
}
</code></pre></div><p>The first argument for <code>Map</code> is a <code>PathString</code> representing the path prefix of the request. The second argument is a delegate that configures the branch&rsquo;s pipeline (the <code>a</code> parameter represents the <code>IApplicationBuilder</code> for the branch). The branch defined by the delegate will process the request if its path starts with the specified path prefix.</p>
<p>For a request that doesn&rsquo;t start with <code>/foo</code>, this code produces the following output:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A (before)
C
A (after)
</code></pre></div><p>Middleware B is not invoked, since it&rsquo;s in the branch and the request doesn&rsquo;t match the prefix for the branch. But for a request that does start with <code>/foo</code>, we get the following output:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A (before)
B (before)
B (after)
A (after)
</code></pre></div><p>Note that this request returns a 404 (Not found) response: this is because the B middleware calls <code>next()</code>, but there&rsquo;s no next middleware, so it falls back to returning a 404 response. To solve this, we could use <code>Run</code> instead of <code>Use</code>, or just not call <code>next()</code>.</p>
<p>The pipeline defined by this code can be represented as follows:</p>
<p><img src="non-rejoining.png" alt="Non-rejoining branch"></p>
<p>(I omited the response arrows for clarity)</p>
<p>As you can see, the branch with middleware B doesn&rsquo;t rejoin the main pipeline, so middleware C isn&rsquo;t called.</p>
<h3 id="making-a-rejoining-branch">Making a rejoining branch</h3>
<p>You can make a branch that rejoins the main pipeline by using the <code>UseWhen</code> method. This method accepts a predicate on the <code>HttpContext</code> to decide whether to branch or not. The branch will rejoin the main pipeline where it left it. Here&rsquo;s an example similar to the previous one, but with a rejoining branch:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Configure(IApplicationBuilder app)
{
    app.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;A (before)&#34;</span>);
        <span style="color:#66d9ef">await</span> next();
        Console.WriteLine(<span style="color:#e6db74">&#34;A (after)&#34;</span>);
    });

    app.UseWhen(
        context =&gt; context.Request.Path.StartsWithSegments(<span style="color:#66d9ef">new</span> PathString(<span style="color:#e6db74">&#34;/foo&#34;</span>)),
        a =&gt; a.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
        {
            Console.WriteLine(<span style="color:#e6db74">&#34;B (before)&#34;</span>);
            <span style="color:#66d9ef">await</span> next();
            Console.WriteLine(<span style="color:#e6db74">&#34;B (after)&#34;</span>);
        }));

    app.Run(<span style="color:#66d9ef">async</span> context =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;C&#34;</span>);
        <span style="color:#66d9ef">await</span> context.Response.WriteAsync(<span style="color:#e6db74">&#34;Hello world&#34;</span>);
    });
}
</code></pre></div><p>For a request that doesn&rsquo;t start with <code>/foo</code>, this code produces the same output as the previous example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A (before)
C
A (after)
</code></pre></div><p>Again, middleware B is not invoked, since it&rsquo;s in the branch and the request doesn&rsquo;t match the predicate for the branch. But for a request that does start with <code>/foo</code>, we get the following output:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A (before)
B (before)
C
B (after)
A (after)
</code></pre></div><p>We can see that the request passes trough the branch (middleware B), then goes back to the main pipeline, ending with middleware C. This pipeline can be represented like this:</p>
<p><img src="rejoining.png" alt="Rejoining branch"></p>
<p>Note that there is no <code>Use</code> method that accepts a <code>PathString</code> to specify the path prefix. I&rsquo;m not sure why it&rsquo;s not included, but it would be easy to write, using <code>UseWhen</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> IApplicationBuilder Use(<span style="color:#66d9ef">this</span> IApplicationBuilder builder, PathString pathMatch, Action&lt;IApplicationBuilder&gt; configuration)
{
    <span style="color:#66d9ef">return</span> builder.UseWhen(
        context =&gt; context.Request.Path.StartsWithSegments(pathMatch),
        configuration);
}
</code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>As you can see, the idea behind the middleware pipeline is quite simple, but it&rsquo;s very powerful. Most of the features baked in ASP.NET Core (authentication, static files, caching, MVC, etc) are implemented as middleware. And of course, it&rsquo;s easy to write your own!</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/.net-core/" rel="tag">.net core</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/asp.net/" rel="tag">asp.net</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/asp.net-core/" rel="tag">asp.net core</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/c/" rel="tag">C#</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/middleware/" rel="tag">middleware</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/pipeline/" rel="tag">pipeline</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>





			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 Thomas Levesque&#39;s .NET Blog.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>