<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Understanding the ASP.NET Core middleware pipeline | Thomas Levesque .NET Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.69.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="Understanding the ASP.NET Core middleware pipeline" />
<meta property="og:description" content="Middlewhat? The ASP.NET Core architecture features a system of middleware, which are pieces of code that handle requests and responses. Middleware are chained to each other to form a pipeline. Incoming requests are passed through the pipeline, where each middleware has a chance to do something with them before passing them to the next middleware. Outgoing responses are also passed through the pipeline, in reverse order. If this sounds very abstract, the following schema from the official ASP." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog2.thomaslevesque.net/2018/03/27/understanding-the-asp-net-core-middleware-pipeline/" />
<meta property="article:published_time" content="2018-03-27T06:00:38+00:00" />
<meta property="article:modified_time" content="2018-03-27T06:00:38+00:00" />
<meta itemprop="name" content="Understanding the ASP.NET Core middleware pipeline">
<meta itemprop="description" content="Middlewhat? The ASP.NET Core architecture features a system of middleware, which are pieces of code that handle requests and responses. Middleware are chained to each other to form a pipeline. Incoming requests are passed through the pipeline, where each middleware has a chance to do something with them before passing them to the next middleware. Outgoing responses are also passed through the pipeline, in reverse order. If this sounds very abstract, the following schema from the official ASP.">
<meta itemprop="datePublished" content="2018-03-27T06:00:38&#43;00:00" />
<meta itemprop="dateModified" content="2018-03-27T06:00:38&#43;00:00" />
<meta itemprop="wordCount" content="1213">



<meta itemprop="keywords" content=".net core,asp.net,asp.net core,C#,middleware,pipeline," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Understanding the ASP.NET Core middleware pipeline"/>
<meta name="twitter:description" content="Middlewhat? The ASP.NET Core architecture features a system of middleware, which are pieces of code that handle requests and responses. Middleware are chained to each other to form a pipeline. Incoming requests are passed through the pipeline, where each middleware has a chance to do something with them before passing them to the next middleware. Outgoing responses are also passed through the pipeline, in reverse order. If this sounds very abstract, the following schema from the official ASP."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://blog2.thomaslevesque.net/" class="f3 fw2 hover-white no-underline white-90 dib">
      Thomas Levesque .NET Blog
    </a>
    <div class="flex-l items-center">
      

      
      














    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://blog2.thomaslevesque.net/2018/03/27/understanding-the-asp-net-core-middleware-pipeline/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://blog2.thomaslevesque.net/2018/03/27/understanding-the-asp-net-core-middleware-pipeline/&amp;text=Understanding%20the%20ASP.NET%20Core%20middleware%20pipeline" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog2.thomaslevesque.net/2018/03/27/understanding-the-asp-net-core-middleware-pipeline/&amp;title=Understanding%20the%20ASP.NET%20Core%20middleware%20pipeline" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>

      <h1 class="f1 athelas mt3 mb1">Understanding the ASP.NET Core middleware pipeline</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-03-27T06:00:38Z">March 27, 2018</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="middlewhat">Middlewhat?</h2>
<p>The ASP.NET Core architecture features a system of <strong>middleware</strong>, which are pieces of code that handle requests and responses. Middleware are chained to each other to form a <strong>pipeline</strong>. Incoming requests are passed through the pipeline, where each middleware has a chance to do something with them before passing them to the next middleware. Outgoing responses are also passed through the pipeline, in reverse order. If this sounds very abstract, the following schema from the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware">official ASP.NET Core documentation</a> should help you understand:</p>
<p><img src="request-delegate-pipeline.png" alt="Middleware pipeline"></p>
<p>Middleware can do all sort of things, such as handling authentication, errors, static files, etc&hellip; MVC in ASP.NET Core is also implemented as a middleware.</p>
<h2 id="configuring-the-pipeline">Configuring the pipeline</h2>
<p>You typically configure the ASP.NET pipeline in the <code>Configure</code> method of your <code>Startup</code> class, by calling <code>Use*</code> methods on the <code>IApplicationBuilder</code>. Here&rsquo;s an example straight from the docs:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Configure(IApplicationBuilder app)
{
    app.UseExceptionHandler(<span style="color:#e6db74">&#34;/Home/Error&#34;</span>);
    app.UseStaticFiles();
    app.UseAuthentication();
    app.UseMvcWithDefaultRoute();
}
</code></pre></div><p>Each <code>Use*</code> method adds a middleware to the pipeline. The order in which they&rsquo;re added determines the order in which requests will traverse them. So an incoming request will first traverse the exception handler middleware, then the static files middleware, then the authentication middleware, and will eventually be handled by the MVC middleware.</p>
<p>The <code>Use*</code> methods in this example are actually just &ldquo;shortcuts&rdquo; to make it easier to build the pipeline. Behind the scenes, they all end up using (directly or indirectly) these low-level primitives: <code>Use</code> and <code>Run</code>. Both add a middleware to the pipeline, the difference is that <code>Run</code> adds a <em>terminal</em> middleware, i.e. a middleware that is the last in the pipeline.</p>
<h2 id="a-basic-pipeline-with-no-branches">A basic pipeline with no branches</h2>
<p>Let&rsquo;s look at a simple example, using only the <code>Use</code> and <code>Run</code> primitives:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Configure(IApplicationBuilder app)
{
    <span style="color:#75715e">// Middleware A
</span><span style="color:#75715e"></span>    app.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;A (before)&#34;</span>);
        <span style="color:#66d9ef">await</span> next();
        Console.WriteLine(<span style="color:#e6db74">&#34;A (after)&#34;</span>);
    });

    <span style="color:#75715e">// Middleware B
</span><span style="color:#75715e"></span>    app.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;B (before)&#34;</span>);
        <span style="color:#66d9ef">await</span> next();
        Console.WriteLine(<span style="color:#e6db74">&#34;B (after)&#34;</span>);
    });

    <span style="color:#75715e">// Middleware C (terminal)
</span><span style="color:#75715e"></span>    app.Run(<span style="color:#66d9ef">async</span> context =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;C&#34;</span>);
        <span style="color:#66d9ef">await</span> context.Response.WriteAsync(<span style="color:#e6db74">&#34;Hello world&#34;</span>);
    });
}
</code></pre></div><p>Here, each middleware is defined inline as an anonymous method; they could also be defined as full-blown classes, but for this example I picked the more concise option. Non-terminal middleware take two arguments: the <code>HttpContext</code> and a delegate to call the next middleware. Terminal middleware only take the <code>HttpContext</code>. Here we have two middleware A and B that just log to the console, and a terminal middleware C which writes the response. Here&rsquo;s the console output when we send a request to our app:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">
A (before)
B (before)
C
B (after)
A (after)
</code></pre></div><p>We can see that each middleware was traversed in the order in which it was added, then traversed again in reverse order. The pipeline can be represented like this:</p>
<p><img src="basic-pipeline.png" alt="Basic pipeline"></p>
<h2 id="short-circuiting-middleware">Short-circuiting middleware</h2>
<p>A middleware doesn&rsquo;t necessarily have to call the next middleware. For instance, if the static files middleware can handle a request, it doesn&rsquo;t need to pass it down to the rest of the pipeline, it can respond immediately. This behavior is called short-circuiting the pipeline.</p>
<p>In the previous example, if we comment out the call to <code>next()</code> in middleware B, we get the following output:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">
A (before)
B (before)
B (after)
A (after)
</code></pre></div><p>As you can see, middleware C is never invoked. The pipeline now looks like this:</p>
<p><img src="short-circuit.png" alt="Short-circuited pipeline"></p>
<h2 id="branching-the-pipeline">Branching the pipeline</h2>
<p>In the previous examples, there was only one &ldquo;branch&rdquo; in the pipeline: the middleware coming after A was always B, and the middleware coming after B was always C. But it doesn&rsquo;t have to be that way. You might want a given request to be processed by a completely different pipeline, based on the path or anything else.</p>
<p>There are two types of branches: branches that rejoin the main pipeline, and branches that don&rsquo;t.</p>
<h3 id="making-a-non-rejoining-branch">Making a non-rejoining branch</h3>
<p>This can be done using the <code>Map</code> or <code>MapWhen</code> method. <code>Map</code> lets you specify a branch based on the request path. <code>MapWhen</code> gives you more control: you can specify a predicate on the <code>HttpContext</code> to decide whether to branch or not. Let&rsquo;s look at a simple example using <code>Map</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Configure(IApplicationBuilder app)
{
    app.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;A (before)&#34;</span>);
        <span style="color:#66d9ef">await</span> next();
        Console.WriteLine(<span style="color:#e6db74">&#34;A (after)&#34;</span>);
    });

    app.Map(
        <span style="color:#66d9ef">new</span> PathString(<span style="color:#e6db74">&#34;/foo&#34;</span>),
        a =&gt; a.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
        {
            Console.WriteLine(<span style="color:#e6db74">&#34;B (before)&#34;</span>);
            <span style="color:#66d9ef">await</span> next();
            Console.WriteLine(<span style="color:#e6db74">&#34;B (after)&#34;</span>);
        }));

    app.Run(<span style="color:#66d9ef">async</span> context =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;C&#34;</span>);
        <span style="color:#66d9ef">await</span> context.Response.WriteAsync(<span style="color:#e6db74">&#34;Hello world&#34;</span>);
    });
}
</code></pre></div><p>The first argument for <code>Map</code> is a <code>PathString</code> representing the path prefix of the request. The second argument is a delegate that configures the branch&rsquo;s pipeline (the <code>a</code> parameter represents the <code>IApplicationBuilder</code> for the branch). The branch defined by the delegate will process the request if its path starts with the specified path prefix.</p>
<p>For a request that doesn&rsquo;t start with <code>/foo</code>, this code produces the following output:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">
A (before)
C
A (after)
</code></pre></div><p>Middleware B is not invoked, since it&rsquo;s in the branch and the request doesn&rsquo;t match the prefix for the branch. But for a request that does start with <code>/foo</code>, we get the following output:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">
A (before)
B (before)
B (after)
A (after)
</code></pre></div><p>Note that this request returns a 404 (Not found) response: this is because the B middleware calls <code>next()</code>, but there&rsquo;s no next middleware, so it falls back to returning a 404 response. To solve this, we could use <code>Run</code> instead of <code>Use</code>, or just not call <code>next()</code>.</p>
<p>The pipeline defined by this code can be represented as follows:</p>
<p><img src="non-rejoining.png" alt="Non-rejoining branch"></p>
<p>(I omited the response arrows for clarity)</p>
<p>As you can see, the branch with middleware B doesn&rsquo;t rejoin the main pipeline, so middleware C isn&rsquo;t called.</p>
<h3 id="making-a-rejoining-branch">Making a rejoining branch</h3>
<p>You can make a branch that rejoins the main pipeline by using the <code>UseWhen</code> method. This method accepts a predicate on the <code>HttpContext</code> to decide whether to branch or not. The branch will rejoin the main pipeline where it left it. Here&rsquo;s an example similar to the previous one, but with a rejoining branch:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Configure(IApplicationBuilder app)
{
    app.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;A (before)&#34;</span>);
        <span style="color:#66d9ef">await</span> next();
        Console.WriteLine(<span style="color:#e6db74">&#34;A (after)&#34;</span>);
    });

    app.UseWhen(
        context =&gt; context.Request.Path.StartsWithSegments(<span style="color:#66d9ef">new</span> PathString(<span style="color:#e6db74">&#34;/foo&#34;</span>)),
        a =&gt; a.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
        {
            Console.WriteLine(<span style="color:#e6db74">&#34;B (before)&#34;</span>);
            <span style="color:#66d9ef">await</span> next();
            Console.WriteLine(<span style="color:#e6db74">&#34;B (after)&#34;</span>);
        }));

    app.Run(<span style="color:#66d9ef">async</span> context =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;C&#34;</span>);
        <span style="color:#66d9ef">await</span> context.Response.WriteAsync(<span style="color:#e6db74">&#34;Hello world&#34;</span>);
    });
}
</code></pre></div><p>For a request that doesn&rsquo;t start with <code>/foo</code>, this code produces the same output as the previous example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">
A (before)
C
A (after)
</code></pre></div><p>Again, middleware B is not invoked, since it&rsquo;s in the branch and the request doesn&rsquo;t match the predicate for the branch. But for a request that does start with <code>/foo</code>, we get the following output:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">
A (before)
B (before)
C
B (after)
A (after)
</code></pre></div><p>We can see that the request passes trough the branch (middleware B), then goes back to the main pipeline, ending with middleware C. This pipeline can be represented like this:</p>
<p><img src="rejoining.png" alt="Rejoining branch"></p>
<p>Note that there is no <code>Use</code> method that accepts a <code>PathString</code> to specify the path prefix. I&rsquo;m not sure why it&rsquo;s not included, but it would be easy to write, using <code>UseWhen</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> IApplicationBuilder Use(<span style="color:#66d9ef">this</span> IApplicationBuilder builder, PathString pathMatch, Action&lt;IApplicationBuilder&gt; configuration)
{
    <span style="color:#66d9ef">return</span> builder.UseWhen(
        context =&gt; context.Request.Path.StartsWithSegments(pathMatch),
        configuration);
}
</code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>As you can see, the idea behind the middleware pipeline is quite simple, but it&rsquo;s very powerful. Most of the features baked in ASP.NET Core (authentication, static files, caching, MVC, etc) are implemented as middleware. And of course, it&rsquo;s easy to write your own!</p>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/.net-core" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">.net core</a>
   </li>
  
   <li class="list">
     <a href="/tags/asp.net" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">asp.net</a>
   </li>
  
   <li class="list">
     <a href="/tags/asp.net-core" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">asp.net core</a>
   </li>
  
   <li class="list">
     <a href="/tags/c" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">C#</a>
   </li>
  
   <li class="list">
     <a href="/tags/middleware" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">middleware</a>
   </li>
  
   <li class="list">
     <a href="/tags/pipeline" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">pipeline</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/2017/03/29/linq-performance-improvements-in-net-core/">Linq performance improvements in .NET Core</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2016/12/08/fun-with-the-httpclient-pipeline/">Fun with the HttpClient pipeline</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2018/02/25/better-timeout-handling-with-httpclient/">Better timeout handling with HttpClient</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2017/09/18/common-msbuild-properties-and-items-with-directory-build-props/">Common MSBuild properties and items with Directory.Build.props</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2017/08/26/testing-and-debugging-library-code-from-linqpad/">Testing and debugging library code from LINQPad</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2017/01/17/c-methods-in-git-diff-hunk-headers/">C# methods in git diff hunk headers</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2016/08/23/tuple-deconstruction-in-c-7/">Tuple deconstruction in C# 7</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2016/07/25/tuples-in-c-7/">Tuples in C# 7</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2016/06/21/pitfall-using-var-and-async-together/">Pitfall: using var and async together</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2016/04/16/test-driving-c-7-features-in-visual-studio-15-preview/">Test driving C# 7 features in Visual Studio “15” Preview</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2016/01/17/automatically-inject-fakes-in-test-fixture-with-fakeiteasy/">Automatically inject fakes in test fixture with FakeItEasy</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/12/31/using-multiple-cancellation-sources-with-createlinkedtokensource/">Using multiple cancellation sources with CreateLinkedTokenSource</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/11/11/explicitly-switch-to-the-ui-thread-in-an-async-method/">Explicitly switch to the UI thread in an async method</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/09/05/wpf-prevent-the-user-from-pasting-an-image-in-a-richtextbox/">[WPF] Prevent the user from pasting an image in a RichTextBox</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/07/30/c-puzzle-2/">C# Puzzle 2</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://blog2.thomaslevesque.net/" >
    &copy;  Thomas Levesque .NET Blog 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
