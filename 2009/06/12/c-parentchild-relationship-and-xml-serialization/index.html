<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>[C#] Parent/child relationship and XML serialization | Thomas Levesque .NET Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.69.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="[C#] Parent/child relationship and XML serialization" />
<meta property="og:description" content="Today I&rsquo;d like to present an idea that occurred to me recently. Nothing about WPF this time, this is all about C# class design ! The problem It&rsquo;s very common in C# programs to have an object that owns a collection of child items with a reference to their parent. For instance, this is the case for Windows Forms controls, which have a collection of child controls (Controls), and a reference to their parent control (Parent)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog2.thomaslevesque.net/2009/06/12/c-parentchild-relationship-and-xml-serialization/" />
<meta property="article:published_time" content="2009-06-12T10:18:22+00:00" />
<meta property="article:modified_time" content="2009-06-12T10:18:22+00:00" />
<meta itemprop="name" content="[C#] Parent/child relationship and XML serialization">
<meta itemprop="description" content="Today I&rsquo;d like to present an idea that occurred to me recently. Nothing about WPF this time, this is all about C# class design ! The problem It&rsquo;s very common in C# programs to have an object that owns a collection of child items with a reference to their parent. For instance, this is the case for Windows Forms controls, which have a collection of child controls (Controls), and a reference to their parent control (Parent).">
<meta itemprop="datePublished" content="2009-06-12T10:18:22&#43;00:00" />
<meta itemprop="dateModified" content="2009-06-12T10:18:22&#43;00:00" />
<meta itemprop="wordCount" content="1140">



<meta itemprop="keywords" content="C#,collection,parent/child,XML serialization," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[C#] Parent/child relationship and XML serialization"/>
<meta name="twitter:description" content="Today I&rsquo;d like to present an idea that occurred to me recently. Nothing about WPF this time, this is all about C# class design ! The problem It&rsquo;s very common in C# programs to have an object that owns a collection of child items with a reference to their parent. For instance, this is the case for Windows Forms controls, which have a collection of child controls (Controls), and a reference to their parent control (Parent)."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://blog2.thomaslevesque.net/" class="f3 fw2 hover-white no-underline white-90 dib">
      Thomas Levesque .NET Blog
    </a>
    <div class="flex-l items-center">
      

      
      














    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://blog2.thomaslevesque.net/2009/06/12/c-parentchild-relationship-and-xml-serialization/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://blog2.thomaslevesque.net/2009/06/12/c-parentchild-relationship-and-xml-serialization/&amp;text=[C#]%20Parent/child%20relationship%20and%20XML%20serialization" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog2.thomaslevesque.net/2009/06/12/c-parentchild-relationship-and-xml-serialization/&amp;title=[C#]%20Parent/child%20relationship%20and%20XML%20serialization" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>

      <h1 class="f1 athelas mt3 mb1">[C#] Parent/child relationship and XML serialization</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2009-06-12T10:18:22Z">June 12, 2009</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>Today I&rsquo;d like to present an idea that occurred to me recently. Nothing about WPF this time, this is all about C# class design !  <strong>The problem</strong>  It&rsquo;s very common in C# programs to have an object that owns a collection of child items with a reference to their parent. For instance, this is the case for Windows Forms controls, which have a collection of child controls (<code>Controls</code>), and a reference to their parent control (<code>Parent</code>).  This kind of structure is quite easy to implement, it just requires a bit of plumbing to maintain the consistency of the parent/child relationship. However, if you want to serialize the parent object to XML, it can get tricky&hellip; Let&rsquo;s take a simple, purely theoretical example :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parent</span>
    {
        <span style="color:#66d9ef">public</span> Parent()
        {
            <span style="color:#66d9ef">this</span>.Children = <span style="color:#66d9ef">new</span> List&lt;Child&gt;();
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

        <span style="color:#66d9ef">public</span> List&lt;Child&gt; Children { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> AddChild(Child child)
        {
            child.ParentObject = <span style="color:#66d9ef">this</span>;
            <span style="color:#66d9ef">this</span>.Children.Add(child);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> RemoveChild(Child child)
        {
            <span style="color:#66d9ef">this</span>.Children.Remove(child);
            child.ParentObject = <span style="color:#66d9ef">null</span>;
        }
    }
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Child</span>
    {
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

        <span style="color:#66d9ef">public</span> Parent ParentObject { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
    }
</code></pre></div><p>Let&rsquo;s create an instance of <code>Parent</code> with a few children, and try to serialize it to XML :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">            Parent p = <span style="color:#66d9ef">new</span> Parent { Name = <span style="color:#e6db74">&#34;The parent&#34;</span> };
            p.AddChild(<span style="color:#66d9ef">new</span> Child { Name = <span style="color:#e6db74">&#34;First child&#34;</span> });
            p.AddChild(<span style="color:#66d9ef">new</span> Child { Name = <span style="color:#e6db74">&#34;Second child&#34;</span> });

            <span style="color:#66d9ef">string</span> xml;
            XmlSerializer xs = <span style="color:#66d9ef">new</span> XmlSerializer(<span style="color:#66d9ef">typeof</span>(Parent));
            <span style="color:#66d9ef">using</span> (StringWriter wr = <span style="color:#66d9ef">new</span> StringWriter())
            {
                xs.Serialize(wr, p);
                xml = wr.ToString();
            }

            Console.WriteLine(xml);
</code></pre></div><p>When we try to serialize the <code>Parent</code> object, an <code>InvalidOperationException</code> occurs, saying that a circular reference was detected : indeed, the parent references the children, which in turn reference the parent, which references the children&hellip; and so on. The obvious solution to that issue is to suppress the serialization of the <code>Child.ParentObject</code> property, which can be done easily by using the <code>XmlIgnore</code> attribute. With that change the serialization works fine, but the problem is not solved yet : when we deserialize the object, the <code>ParentObject</code> property of the children is not set, since it wasn&rsquo;t serialized&hellip; the consistency of the parent/child relationship is broken !  A simple and naive solution would be to loop through the <code>Children</code> collection after the deserialization, in order to set the <code>ParentObject</code> manually. But it&rsquo;s definitely not an elegant approach&hellip; and since I really like elegant code, I thought of something else ;)  <strong>The solution</strong>  The idea I had to solve this problem consists of a specialized generic collection <code>ChildItemCollection&lt;P,T&gt;</code>, and a <code>IChildItem&lt;P&gt;</code> interface that must be implemented by children.  The <code>IChildItem&lt;P&gt;</code> interface just defines a <code>Parent</code> property of type P :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#75715e">/// &lt;summary&gt;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// Defines the contract for an object that has a parent object
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// &lt;/summary&gt;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// &lt;typeparam name=&#34;P&#34;&gt;Type of the parent object&lt;/typeparam&gt;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> IChildItem&lt;P&gt; <span style="color:#66d9ef">where</span> P : <span style="color:#66d9ef">class</span>
    {
        P Parent { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
    }
</code></pre></div><p>The <code>ChildItemCollection&lt;P,T&gt;</code> class implements <code>IList&lt;T&gt;</code> by delegating the implementation to a <code>List&lt;T&gt;</code> (or to a collection passed to the constructor), and maintains the parent/child relationship :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#75715e">/// &lt;summary&gt;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// Collection of child items. This collection automatically set the
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// Parent property of the child items when they are added or removed
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// &lt;/summary&gt;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// &lt;typeparam name=&#34;P&#34;&gt;Type of the parent object&lt;/typeparam&gt;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// &lt;typeparam name=&#34;T&#34;&gt;Type of the child items&lt;/typeparam&gt;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ChildItemCollection</span>&lt;P, T&gt; : IList&lt;T&gt;
        <span style="color:#66d9ef">where</span> P : <span style="color:#66d9ef">class</span>
        <span style="color:#a6e22e">where</span> T : IChildItem&lt;P&gt;
    {
        <span style="color:#66d9ef">private</span> P _parent;
        <span style="color:#66d9ef">private</span> IList&lt;T&gt; _collection;

        <span style="color:#66d9ef">public</span> ChildItemCollection(P parent)
        {
            <span style="color:#66d9ef">this</span>._parent = parent;
            <span style="color:#66d9ef">this</span>._collection = <span style="color:#66d9ef">new</span> List&lt;T&gt;();
        }

        <span style="color:#66d9ef">public</span> ChildItemCollection(P parent, IList&lt;T&gt; collection)
        {
            <span style="color:#66d9ef">this</span>._parent = parent;
            <span style="color:#66d9ef">this</span>._collection = collection;
        }

        <span style="color:#75715e">#region IList&lt;T&gt; Members
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> IndexOf(T item)
        {
            <span style="color:#66d9ef">return</span> _collection.IndexOf(item);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Insert(<span style="color:#66d9ef">int</span> index, T item)
        {
            <span style="color:#66d9ef">if</span> (item != <span style="color:#66d9ef">null</span>)
                item.Parent = _parent;
            _collection.Insert(index, item);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> RemoveAt(<span style="color:#66d9ef">int</span> index)
        {
            T oldItem = _collection[index];
            _collection.RemoveAt(index);
            <span style="color:#66d9ef">if</span> (oldItem != <span style="color:#66d9ef">null</span>)
                oldItem.Parent = <span style="color:#66d9ef">null</span>;
        }

        <span style="color:#66d9ef">public</span> T <span style="color:#66d9ef">this</span>[<span style="color:#66d9ef">int</span> index]
        {
            <span style="color:#66d9ef">get</span>
            {
                <span style="color:#66d9ef">return</span> _collection[index];
            }
            <span style="color:#66d9ef">set</span>
            {
                T oldItem = _collection[index];
                <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">value</span> != <span style="color:#66d9ef">null</span>)
                    <span style="color:#66d9ef">value</span>.Parent = _parent;
                _collection[index] = <span style="color:#66d9ef">value</span>;
                <span style="color:#66d9ef">if</span> (oldItem != <span style="color:#66d9ef">null</span>)
                    oldItem.Parent = <span style="color:#66d9ef">null</span>;
            }
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">#region ICollection&lt;T&gt; Members
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Add(T item)
        {
            <span style="color:#66d9ef">if</span> (item != <span style="color:#66d9ef">null</span>)
                item.Parent = _parent;
            _collection.Add(item);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Clear()
        {
            <span style="color:#66d9ef">foreach</span> (T item <span style="color:#66d9ef">in</span> _collection)
            {
                <span style="color:#66d9ef">if</span> (item != <span style="color:#66d9ef">null</span>)
                    item.Parent = <span style="color:#66d9ef">null</span>;
            }
            _collection.Clear();
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Contains(T item)
        {
            <span style="color:#66d9ef">return</span> _collection.Contains(item);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> CopyTo(T[] array, <span style="color:#66d9ef">int</span> arrayIndex)
        {
            _collection.CopyTo(array, arrayIndex);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Count
        {
            <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> _collection.Count; }
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsReadOnly
        {
            <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> _collection.IsReadOnly; }
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Remove(T item)
        {
            <span style="color:#66d9ef">bool</span> b = _collection.Remove(item);
            <span style="color:#66d9ef">if</span> (item != <span style="color:#66d9ef">null</span>)
                item.Parent = <span style="color:#66d9ef">null</span>;
            <span style="color:#66d9ef">return</span> b;
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">#region IEnumerable&lt;T&gt; Members
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">public</span> IEnumerator&lt;T&gt; GetEnumerator()
        {
            <span style="color:#66d9ef">return</span> _collection.GetEnumerator();
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">#region IEnumerable Members
</span><span style="color:#75715e"></span>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            <span style="color:#66d9ef">return</span> (_collection <span style="color:#66d9ef">as</span> System.Collections.IEnumerable).GetEnumerator();
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>    }
</code></pre></div><p>Now let&rsquo;s see how this class can be used in the case of the above example&hellip; First let&rsquo;s change the <code>Child</code> class so that it implements the <code>IChildItem&lt;Parent&gt;</code> interface :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Child</span> : IChildItem&lt;Parent&gt;
    {
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">        [XmlIgnore]</span>
        <span style="color:#66d9ef">public</span> Parent ParentObject { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">set</span>; }

        <span style="color:#75715e">#region IChildItem&lt;Parent&gt; Members
</span><span style="color:#75715e"></span>
        Parent IChildItem&lt;Parent&gt;.Parent
        {
            <span style="color:#66d9ef">get</span>
            {
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.ParentObject;
            }
            <span style="color:#66d9ef">set</span>
            {
                <span style="color:#66d9ef">this</span>.ParentObject = <span style="color:#66d9ef">value</span>;
            }
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>    }
</code></pre></div><p>Note that here the <code>IChildItem&lt;Parent&gt;</code> interface is implemented <em>explicitly</em> : this is a way to &ldquo;hide&rdquo; the <code>Parent</code> property, that will only be accessible when manipulating the <code>Child</code> object through a variable of type <code>IChildItem&lt;Parent&gt;</code>. We also define the <code>set</code> accessor of the <code>ParentObject</code> property as <code>internal</code>, so that it can&rsquo;t be modified from another assembly.  In the <code>Parent</code> class, the <code>List&lt;Child&gt;</code> just has to be replaced by a <code>ChildItemCollection&lt;Parent, Child&gt;</code>. We also remove the <code>AddChild</code> and <code>RemoveChild</code> methods, which are no more necessary since the <code>ChildItemCollection&lt;P,T&gt;</code> takes care of setting the <code>Parent</code> property.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parent</span>
    {
        <span style="color:#66d9ef">public</span> Parent()
        {
            <span style="color:#66d9ef">this</span>.Children = <span style="color:#66d9ef">new</span> ChildItemCollection&lt;Parent, Child&gt;(<span style="color:#66d9ef">this</span>);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

        <span style="color:#66d9ef">public</span> ChildItemCollection&lt;Parent, Child&gt; Children { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">set</span>; }
    }
</code></pre></div><p>Note that we give the <code>ChildItemCollection&lt;Parent, Child&gt;</code> constructor a reference to the current object : this is how the collection will know what is the parent of its elements.   The code previously used to serialize a <code>Parent</code> now works fine. During the deserialization, the <code>Child.ParentObject</code> property is not assigned when the <code>Child</code> itself is deserialized (since it has the <code>XmlIgnore</code> attribute), but when the <code>Child</code> is added to the <code>Parent.Children</code> collection.  Eventually, we can see that this solution enables us to keep the parent/child relationship when the object graph is serialized to XML, without resorting to unelegant tricks&hellip; However, note that the consistency of the relation can still be broken, if the <code>ParentObject</code> is changed by code outside the <code>ChildItemCollection&lt;P,T&gt;</code> class. To prevent that, some logic must be added to the <code>set</code> accessor to maintain the consistency ; I only omitted that part for the sake of clarity and simplicity.</p>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/c" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">C#</a>
   </li>
  
   <li class="list">
     <a href="/tags/collection" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">collection</a>
   </li>
  
   <li class="list">
     <a href="/tags/parent/child" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">parent/child</a>
   </li>
  
   <li class="list">
     <a href="/tags/xml-serialization" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">XML serialization</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/2009/04/17/wpf-binding-to-an-asynchronous-collection/">[WPF] Binding to an asynchronous collection</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://blog2.thomaslevesque.net/" >
    &copy;  Thomas Levesque .NET Blog 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
