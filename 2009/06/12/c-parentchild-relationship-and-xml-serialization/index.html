<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>[C#] Parent/child relationship and XML serialization - Thomas Levesque&#39;s .NET Blog</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	
	
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-31621259-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Thomas Levesque&#39;s .NET Blog" rel="home">
				<div class="logo__title">Thomas Levesque&#39;s .NET Blog</div>
				
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[C#] Parent/child relationship and XML serialization</h1>
			
		</header><div class="content post__content clearfix">
			<p>Today I&rsquo;d like to present an idea that occurred to me recently. Nothing about WPF this time, this is all about C# class design !  <strong>The problem</strong>  It&rsquo;s very common in C# programs to have an object that owns a collection of child items with a reference to their parent. For instance, this is the case for Windows Forms controls, which have a collection of child controls (<code>Controls</code>), and a reference to their parent control (<code>Parent</code>).  This kind of structure is quite easy to implement, it just requires a bit of plumbing to maintain the consistency of the parent/child relationship. However, if you want to serialize the parent object to XML, it can get tricky&hellip; Let&rsquo;s take a simple, purely theoretical example :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parent</span>
    {
        <span style="color:#66d9ef">public</span> Parent()
        {
            <span style="color:#66d9ef">this</span>.Children = <span style="color:#66d9ef">new</span> List&lt;Child&gt;();
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

        <span style="color:#66d9ef">public</span> List&lt;Child&gt; Children { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> AddChild(Child child)
        {
            child.ParentObject = <span style="color:#66d9ef">this</span>;
            <span style="color:#66d9ef">this</span>.Children.Add(child);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> RemoveChild(Child child)
        {
            <span style="color:#66d9ef">this</span>.Children.Remove(child);
            child.ParentObject = <span style="color:#66d9ef">null</span>;
        }
    }
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Child</span>
    {
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

        <span style="color:#66d9ef">public</span> Parent ParentObject { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
    }
</code></pre></div><p>Let&rsquo;s create an instance of <code>Parent</code> with a few children, and try to serialize it to XML :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">            Parent p = <span style="color:#66d9ef">new</span> Parent { Name = <span style="color:#e6db74">&#34;The parent&#34;</span> };
            p.AddChild(<span style="color:#66d9ef">new</span> Child { Name = <span style="color:#e6db74">&#34;First child&#34;</span> });
            p.AddChild(<span style="color:#66d9ef">new</span> Child { Name = <span style="color:#e6db74">&#34;Second child&#34;</span> });

            <span style="color:#66d9ef">string</span> xml;
            XmlSerializer xs = <span style="color:#66d9ef">new</span> XmlSerializer(<span style="color:#66d9ef">typeof</span>(Parent));
            <span style="color:#66d9ef">using</span> (StringWriter wr = <span style="color:#66d9ef">new</span> StringWriter())
            {
                xs.Serialize(wr, p);
                xml = wr.ToString();
            }

            Console.WriteLine(xml);
</code></pre></div><p>When we try to serialize the <code>Parent</code> object, an <code>InvalidOperationException</code> occurs, saying that a circular reference was detected : indeed, the parent references the children, which in turn reference the parent, which references the children&hellip; and so on. The obvious solution to that issue is to suppress the serialization of the <code>Child.ParentObject</code> property, which can be done easily by using the <code>XmlIgnore</code> attribute. With that change the serialization works fine, but the problem is not solved yet : when we deserialize the object, the <code>ParentObject</code> property of the children is not set, since it wasn&rsquo;t serialized&hellip; the consistency of the parent/child relationship is broken !  A simple and naive solution would be to loop through the <code>Children</code> collection after the deserialization, in order to set the <code>ParentObject</code> manually. But it&rsquo;s definitely not an elegant approach&hellip; and since I really like elegant code, I thought of something else ;)  <strong>The solution</strong>  The idea I had to solve this problem consists of a specialized generic collection <code>ChildItemCollection&lt;P,T&gt;</code>, and a <code>IChildItem&lt;P&gt;</code> interface that must be implemented by children.  The <code>IChildItem&lt;P&gt;</code> interface just defines a <code>Parent</code> property of type P :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#75715e">/// &lt;summary&gt;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// Defines the contract for an object that has a parent object
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// &lt;/summary&gt;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// &lt;typeparam name=&#34;P&#34;&gt;Type of the parent object&lt;/typeparam&gt;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> IChildItem&lt;P&gt; <span style="color:#66d9ef">where</span> P : <span style="color:#66d9ef">class</span>
    {
        P Parent { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
    }
</code></pre></div><p>The <code>ChildItemCollection&lt;P,T&gt;</code> class implements <code>IList&lt;T&gt;</code> by delegating the implementation to a <code>List&lt;T&gt;</code> (or to a collection passed to the constructor), and maintains the parent/child relationship :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#75715e">/// &lt;summary&gt;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// Collection of child items. This collection automatically set the
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// Parent property of the child items when they are added or removed
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// &lt;/summary&gt;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// &lt;typeparam name=&#34;P&#34;&gt;Type of the parent object&lt;/typeparam&gt;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/// &lt;typeparam name=&#34;T&#34;&gt;Type of the child items&lt;/typeparam&gt;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ChildItemCollection</span>&lt;P, T&gt; : IList&lt;T&gt;
        <span style="color:#66d9ef">where</span> P : <span style="color:#66d9ef">class</span>
        <span style="color:#a6e22e">where</span> T : IChildItem&lt;P&gt;
    {
        <span style="color:#66d9ef">private</span> P _parent;
        <span style="color:#66d9ef">private</span> IList&lt;T&gt; _collection;

        <span style="color:#66d9ef">public</span> ChildItemCollection(P parent)
        {
            <span style="color:#66d9ef">this</span>._parent = parent;
            <span style="color:#66d9ef">this</span>._collection = <span style="color:#66d9ef">new</span> List&lt;T&gt;();
        }

        <span style="color:#66d9ef">public</span> ChildItemCollection(P parent, IList&lt;T&gt; collection)
        {
            <span style="color:#66d9ef">this</span>._parent = parent;
            <span style="color:#66d9ef">this</span>._collection = collection;
        }

        <span style="color:#75715e">#region IList&lt;T&gt; Members
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> IndexOf(T item)
        {
            <span style="color:#66d9ef">return</span> _collection.IndexOf(item);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Insert(<span style="color:#66d9ef">int</span> index, T item)
        {
            <span style="color:#66d9ef">if</span> (item != <span style="color:#66d9ef">null</span>)
                item.Parent = _parent;
            _collection.Insert(index, item);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> RemoveAt(<span style="color:#66d9ef">int</span> index)
        {
            T oldItem = _collection[index];
            _collection.RemoveAt(index);
            <span style="color:#66d9ef">if</span> (oldItem != <span style="color:#66d9ef">null</span>)
                oldItem.Parent = <span style="color:#66d9ef">null</span>;
        }

        <span style="color:#66d9ef">public</span> T <span style="color:#66d9ef">this</span>[<span style="color:#66d9ef">int</span> index]
        {
            <span style="color:#66d9ef">get</span>
            {
                <span style="color:#66d9ef">return</span> _collection[index];
            }
            <span style="color:#66d9ef">set</span>
            {
                T oldItem = _collection[index];
                <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">value</span> != <span style="color:#66d9ef">null</span>)
                    <span style="color:#66d9ef">value</span>.Parent = _parent;
                _collection[index] = <span style="color:#66d9ef">value</span>;
                <span style="color:#66d9ef">if</span> (oldItem != <span style="color:#66d9ef">null</span>)
                    oldItem.Parent = <span style="color:#66d9ef">null</span>;
            }
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">#region ICollection&lt;T&gt; Members
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Add(T item)
        {
            <span style="color:#66d9ef">if</span> (item != <span style="color:#66d9ef">null</span>)
                item.Parent = _parent;
            _collection.Add(item);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Clear()
        {
            <span style="color:#66d9ef">foreach</span> (T item <span style="color:#66d9ef">in</span> _collection)
            {
                <span style="color:#66d9ef">if</span> (item != <span style="color:#66d9ef">null</span>)
                    item.Parent = <span style="color:#66d9ef">null</span>;
            }
            _collection.Clear();
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Contains(T item)
        {
            <span style="color:#66d9ef">return</span> _collection.Contains(item);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> CopyTo(T[] array, <span style="color:#66d9ef">int</span> arrayIndex)
        {
            _collection.CopyTo(array, arrayIndex);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Count
        {
            <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> _collection.Count; }
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsReadOnly
        {
            <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> _collection.IsReadOnly; }
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Remove(T item)
        {
            <span style="color:#66d9ef">bool</span> b = _collection.Remove(item);
            <span style="color:#66d9ef">if</span> (item != <span style="color:#66d9ef">null</span>)
                item.Parent = <span style="color:#66d9ef">null</span>;
            <span style="color:#66d9ef">return</span> b;
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">#region IEnumerable&lt;T&gt; Members
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">public</span> IEnumerator&lt;T&gt; GetEnumerator()
        {
            <span style="color:#66d9ef">return</span> _collection.GetEnumerator();
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">#region IEnumerable Members
</span><span style="color:#75715e"></span>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            <span style="color:#66d9ef">return</span> (_collection <span style="color:#66d9ef">as</span> System.Collections.IEnumerable).GetEnumerator();
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>    }
</code></pre></div><p>Now let&rsquo;s see how this class can be used in the case of the above example&hellip; First let&rsquo;s change the <code>Child</code> class so that it implements the <code>IChildItem&lt;Parent&gt;</code> interface :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Child</span> : IChildItem&lt;Parent&gt;
    {
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">        [XmlIgnore]</span>
        <span style="color:#66d9ef">public</span> Parent ParentObject { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">set</span>; }

        <span style="color:#75715e">#region IChildItem&lt;Parent&gt; Members
</span><span style="color:#75715e"></span>
        Parent IChildItem&lt;Parent&gt;.Parent
        {
            <span style="color:#66d9ef">get</span>
            {
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.ParentObject;
            }
            <span style="color:#66d9ef">set</span>
            {
                <span style="color:#66d9ef">this</span>.ParentObject = <span style="color:#66d9ef">value</span>;
            }
        }

        <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>    }
</code></pre></div><p>Note that here the <code>IChildItem&lt;Parent&gt;</code> interface is implemented <em>explicitly</em> : this is a way to &ldquo;hide&rdquo; the <code>Parent</code> property, that will only be accessible when manipulating the <code>Child</code> object through a variable of type <code>IChildItem&lt;Parent&gt;</code>. We also define the <code>set</code> accessor of the <code>ParentObject</code> property as <code>internal</code>, so that it can&rsquo;t be modified from another assembly.  In the <code>Parent</code> class, the <code>List&lt;Child&gt;</code> just has to be replaced by a <code>ChildItemCollection&lt;Parent, Child&gt;</code>. We also remove the <code>AddChild</code> and <code>RemoveChild</code> methods, which are no more necessary since the <code>ChildItemCollection&lt;P,T&gt;</code> takes care of setting the <code>Parent</code> property.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parent</span>
    {
        <span style="color:#66d9ef">public</span> Parent()
        {
            <span style="color:#66d9ef">this</span>.Children = <span style="color:#66d9ef">new</span> ChildItemCollection&lt;Parent, Child&gt;(<span style="color:#66d9ef">this</span>);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

        <span style="color:#66d9ef">public</span> ChildItemCollection&lt;Parent, Child&gt; Children { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">set</span>; }
    }
</code></pre></div><p>Note that we give the <code>ChildItemCollection&lt;Parent, Child&gt;</code> constructor a reference to the current object : this is how the collection will know what is the parent of its elements.   The code previously used to serialize a <code>Parent</code> now works fine. During the deserialization, the <code>Child.ParentObject</code> property is not assigned when the <code>Child</code> itself is deserialized (since it has the <code>XmlIgnore</code> attribute), but when the <code>Child</code> is added to the <code>Parent.Children</code> collection.  Eventually, we can see that this solution enables us to keep the parent/child relationship when the object graph is serialized to XML, without resorting to unelegant tricks&hellip; However, note that the consistency of the relation can still be broken, if the <code>ParentObject</code> is changed by code outside the <code>ChildItemCollection&lt;P,T&gt;</code> class. To prevent that, some logic must be added to the <code>set</code> accessor to maintain the consistency ; I only omitted that part for the sake of clarity and simplicity.</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/c/" rel="tag">C#</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/collection/" rel="tag">collection</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/parent/child/" rel="tag">parent/child</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/xml-serialization/" rel="tag">XML serialization</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>





			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 Thomas Levesque&#39;s .NET Blog.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>