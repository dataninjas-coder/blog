<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>[WPF] Markup extensions and templates - Thomas Levesque&#39;s .NET Blog</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	
	
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-31621259-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Thomas Levesque&#39;s .NET Blog" rel="home">
				<div class="logo__title">Thomas Levesque&#39;s .NET Blog</div>
				
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[WPF] Markup extensions and templates</h1>
			
		</header><div class="content post__content clearfix">
			<p><em>Note : This post follows the one about a <a href="http://www.thomaslevesque.com/2009/07/28/wpf-a-markup-extension-that-can-update-its-target/">a markup extension that can update its target</a>, and reuses the same code.</em>  You may have noticed that using a custom markup extension in a template sometimes lead to unexpected results&hellip; In this post I&rsquo;ll explain what the problem is, and how to create a markup extensions that behaves correctly in a template.  <strong>The problem</strong>  Let&rsquo;s take the example from the previous post : a markup extension which gives the state of network connectivity, and updates its target when the network is connected or disconnected :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;CheckBox</span> <span style="color:#a6e22e">IsChecked=</span><span style="color:#e6db74">&#34;{my:NetworkAvailable}&#34;</span> <span style="color:#a6e22e">Content=</span><span style="color:#e6db74">&#34;Network is available&#34;</span> <span style="color:#f92672">/&gt;</span>
</code></pre></div><p>Now let&rsquo;s put the same <code>CheckBox</code> in a <code>ControlTemplate</code> :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;ControlTemplate</span> <span style="color:#a6e22e">x:Key=</span><span style="color:#e6db74">&#34;test&#34;</span><span style="color:#f92672">&gt;</span>
  <span style="color:#f92672">&lt;CheckBox</span> <span style="color:#a6e22e">IsChecked=</span><span style="color:#e6db74">&#34;{my:NetworkAvailable}&#34;</span> <span style="color:#a6e22e">Content=</span><span style="color:#e6db74">&#34;Network is available&#34;</span> <span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;/ControlTemplate&gt;</span>
</code></pre></div><p>And let&rsquo;s create a control which uses this template :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;Control</span> <span style="color:#a6e22e">Template=</span><span style="color:#e6db74">&#34;{StaticResource test}&#34;</span> <span style="color:#f92672">/&gt;</span>
</code></pre></div><p>If we disconnect from the network, we notice that the <code>CheckBox</code> is not automatically updated by the <code>NetworkAvailableExtension</code>, whereas it was working fine when we used it outside the template&hellip;  <strong>Explanation and solution</strong>  The markup expression is evaluated when it is encountered by the XAML parser : in that case, when the template is parsed. But at this time, the <code>CheckBox</code> control is not created yet, so the <code>ProvideValue</code> method can&rsquo;t access it&hellip; When a markup extension is evaluated inside a template, the <code>TargetObject</code> is actually an instance of <code>System.Windows.SharedDp</code>, an internal WPF class.  For the markup extension to be able to access its target, it has to be evaluated when the template is applied : we need to defer its evaluation until this time. It&rsquo;s actually pretty simple, we just need to return the markup extension itself from <code>ProvideValue</code> : this way, it will be evaluated again when the actual target control is created.  To check if the extension is evaluated for the template or for a &ldquo;real&rdquo; control, we just need to test whether the type of the <code>TargetObject</code> is <code>System.Windows.SharedDp</code>. So the code of the <code>ProvideValue</code> method becomes :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">sealed</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">object</span> ProvideValue(IServiceProvider serviceProvider)
        {
            IProvideValueTarget target = serviceProvider.GetService(<span style="color:#66d9ef">typeof</span>(IProvideValueTarget)) <span style="color:#66d9ef">as</span> IProvideValueTarget;
            <span style="color:#66d9ef">if</span> (target != <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#66d9ef">if</span> (target.TargetObject.GetType().FullName == <span style="color:#e6db74">&#34;System.Windows.SharedDp&#34;</span>)
                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>;
                _targetObject = target.TargetObject;
                _targetProperty = target.TargetProperty;
            }

            <span style="color:#66d9ef">return</span> ProvideValueInternal(serviceProvider);
        }
</code></pre></div><p>Cool, it&rsquo;s now fixed, the <code>CheckBox</code> is updated when the network connectivity changes :)  <strong>Last, but not least</strong>  OK, we have a solution that apparently works fine, but let&rsquo;s not count our chickens before they&rsquo;re hatched&hellip; What if we now want to use our <code>ControlTemplate</code> on several controls ?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;Control</span> <span style="color:#a6e22e">Template=</span><span style="color:#e6db74">&#34;{StaticResource test}&#34;</span> <span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;Control</span> <span style="color:#a6e22e">Template=</span><span style="color:#e6db74">&#34;{StaticResource test}&#34;</span> <span style="color:#f92672">/&gt;</span>
</code></pre></div><p>Now let&rsquo;s run the application and unplug the network cable : the second <code>CheckBox</code> is updated, but the first one is not&hellip;  The reason for this is simple : there are two <code>CheckBox</code> controls, but only one instance of <code>NetworkAvailableExtension</code>, shared between all instances of the template. Now, <code>NetworkAvailableExtension</code> can only reference one target object, so only the last one for which <code>ProvideValue</code> has been called is kept&hellip;  So we need to keep track of not one target object, but a collection of target objects, which will all be update by the <code>UpdateValue</code> method. Here&rsquo;s the final code of the <code>UpdatableMarkupExtension</code> base class :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UpdatableMarkupExtension</span> : MarkupExtension
    {
        <span style="color:#66d9ef">private</span> List&lt;<span style="color:#66d9ef">object</span>&gt; _targetObjects = <span style="color:#66d9ef">new</span> List&lt;<span style="color:#66d9ef">object</span>&gt;();
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">object</span> _targetProperty;

        <span style="color:#66d9ef">protected</span> IEnumerable&lt;<span style="color:#66d9ef">object</span>&gt; TargetObjects
        {
            <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> _targetObjects; }
        }

        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">object</span> TargetProperty
        {
            <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> _targetProperty; }
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">sealed</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">object</span> ProvideValue(IServiceProvider serviceProvider)
        {
            <span style="color:#75715e">// Retrieve target information
</span><span style="color:#75715e"></span>            IProvideValueTarget target = serviceProvider.GetService(<span style="color:#66d9ef">typeof</span>(IProvideValueTarget)) <span style="color:#66d9ef">as</span> IProvideValueTarget;

            <span style="color:#66d9ef">if</span> (target != <span style="color:#66d9ef">null</span> &amp;&amp; target.TargetObject != <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#75715e">// In a template the TargetObject is a SharedDp (internal WPF class)
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// In that case, the markup extension itself is returned to be re-evaluated later
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (target.TargetObject.GetType().FullName == <span style="color:#e6db74">&#34;System.Windows.SharedDp&#34;</span>)
                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>;

                <span style="color:#75715e">// Save target information for later updates
</span><span style="color:#75715e"></span>                _targetObjects.Add(target.TargetObject);
                _targetProperty = target.TargetProperty;
            }

            <span style="color:#75715e">// Delegate the work to the derived class
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> ProvideValueInternal(serviceProvider);
        }

        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> UpdateValue(<span style="color:#66d9ef">object</span> <span style="color:#66d9ef">value</span>)
        {
            <span style="color:#66d9ef">if</span> (_targetObjects.Count &gt; <span style="color:#ae81ff">0</span>)
            {
                <span style="color:#75715e">// Update the target property of each target object
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> target <span style="color:#66d9ef">in</span> _targetObjects)
                {
                    <span style="color:#66d9ef">if</span> (_targetProperty <span style="color:#66d9ef">is</span> DependencyProperty)
                    {
                        DependencyObject obj = target <span style="color:#66d9ef">as</span> DependencyObject;
                        DependencyProperty prop = _targetProperty <span style="color:#66d9ef">as</span> DependencyProperty;

                        Action updateAction = () =&gt; obj.SetValue(prop, <span style="color:#66d9ef">value</span>);

                        <span style="color:#75715e">// Check whether the target object can be accessed from the
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// current thread, and use Dispatcher.Invoke if it can&#39;t
</span><span style="color:#75715e"></span>
                        <span style="color:#66d9ef">if</span> (obj.CheckAccess())
                            updateAction();
                        <span style="color:#66d9ef">else</span>
                            obj.Dispatcher.Invoke(updateAction);
                    }
                    <span style="color:#66d9ef">else</span> <span style="color:#75715e">// _targetProperty is PropertyInfo
</span><span style="color:#75715e"></span>                    {
                        PropertyInfo prop = _targetProperty <span style="color:#66d9ef">as</span> PropertyInfo;
                        prop.SetValue(target, <span style="color:#66d9ef">value</span>, <span style="color:#66d9ef">null</span>);
                    }
                }
            }
        }

        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">object</span> ProvideValueInternal(IServiceProvider serviceProvider);
    }
</code></pre></div><p>The <code>UpdatableMarkupExtension</code> is now fully functional&hellip; until proved otherwise ;). This class makes a good starting point for any markup extension that needs to update its target, without having to worry about the low-level aspects of tracking and updating target objects.</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/markup-extension/" rel="tag">markup extension</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/template/" rel="tag">template</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/wpf/" rel="tag">WPF</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/xaml/" rel="tag">XAML</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>





			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 Thomas Levesque&#39;s .NET Blog.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>