<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>[WPF] Binding to an asynchronous collection | Thomas Levesque .NET Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.69.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="[WPF] Binding to an asynchronous collection" />
<meta property="og:description" content="As you may have noticed, it is not possible to modify the contents of an ObservableCollection on a separate thread if a view is bound to this collection : the CollectionView raises a NotSupportedException :
 This type of CollectionView does not support changes to its SourceCollection from a thread different from the Dispatcher thread
 To illustrate this, let&rsquo;s take a simple example : a ListBox bound to a collection of strings in the ViewModel :" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog2.thomaslevesque.net/2009/04/17/wpf-binding-to-an-asynchronous-collection/" />
<meta property="article:published_time" content="2009-04-17T01:00:19+00:00" />
<meta property="article:modified_time" content="2009-04-17T01:00:19+00:00" />
<meta itemprop="name" content="[WPF] Binding to an asynchronous collection">
<meta itemprop="description" content="As you may have noticed, it is not possible to modify the contents of an ObservableCollection on a separate thread if a view is bound to this collection : the CollectionView raises a NotSupportedException :
 This type of CollectionView does not support changes to its SourceCollection from a thread different from the Dispatcher thread
 To illustrate this, let&rsquo;s take a simple example : a ListBox bound to a collection of strings in the ViewModel :">
<meta itemprop="datePublished" content="2009-04-17T01:00:19&#43;00:00" />
<meta itemprop="dateModified" content="2009-04-17T01:00:19&#43;00:00" />
<meta itemprop="wordCount" content="771">



<meta itemprop="keywords" content="asynchronous,binding,collection,MVVM,WPF," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[WPF] Binding to an asynchronous collection"/>
<meta name="twitter:description" content="As you may have noticed, it is not possible to modify the contents of an ObservableCollection on a separate thread if a view is bound to this collection : the CollectionView raises a NotSupportedException :
 This type of CollectionView does not support changes to its SourceCollection from a thread different from the Dispatcher thread
 To illustrate this, let&rsquo;s take a simple example : a ListBox bound to a collection of strings in the ViewModel :"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://blog2.thomaslevesque.net/" class="f3 fw2 hover-white no-underline white-90 dib">
      Thomas Levesque .NET Blog
    </a>
    <div class="flex-l items-center">
      

      
      














    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://blog2.thomaslevesque.net/2009/04/17/wpf-binding-to-an-asynchronous-collection/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://blog2.thomaslevesque.net/2009/04/17/wpf-binding-to-an-asynchronous-collection/&amp;text=[WPF]%20Binding%20to%20an%20asynchronous%20collection" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog2.thomaslevesque.net/2009/04/17/wpf-binding-to-an-asynchronous-collection/&amp;title=[WPF]%20Binding%20to%20an%20asynchronous%20collection" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>

      <h1 class="f1 athelas mt3 mb1">[WPF] Binding to an asynchronous collection</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2009-04-17T01:00:19Z">April 17, 2009</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>As you may have noticed, it is not possible to modify the contents of an <code>ObservableCollection</code> on a separate thread if a view is bound to this collection : the <code>CollectionView</code> raises a <code>NotSupportedException</code> :</p>
<blockquote>
<p>This type of CollectionView does not support changes to its SourceCollection from a thread different from the Dispatcher thread</p>
</blockquote>
<p>To illustrate this, let&rsquo;s take a simple example : a <code>ListBox</code> bound to a collection of strings in the ViewModel :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">
        <span style="color:#66d9ef">private</span> ObservableCollection&lt;<span style="color:#66d9ef">string</span>&gt; _strings = <span style="color:#66d9ef">new</span> ObservableCollection&lt;<span style="color:#66d9ef">string</span>&gt;();
        <span style="color:#66d9ef">public</span> ObservableCollection&lt;<span style="color:#66d9ef">string</span>&gt; Strings
        {
            <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> _strings; }
            <span style="color:#66d9ef">set</span>
            {
                _strings = <span style="color:#66d9ef">value</span>;
                OnPropertyChanged(<span style="color:#e6db74">&#34;Strings&#34;</span>);
            }
        }
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">
    <span style="color:#f92672">&lt;ListBox</span> <span style="color:#a6e22e">ItemsSource=</span><span style="color:#e6db74">&#34;{Binding Strings}&#34;</span><span style="color:#f92672">/&gt;</span>
</code></pre></div><p>If we add items to this collection out of the main thread, we get the exception mentioned above. A possible solution would be to create a new collection, and assign it to the <code>Strings</code> property when it is filled, but in this case the UI won&rsquo;t reflect progress : all items will appear in the <code>ListBox</code> at the same time after the collection is filled, instead of appearing as they are added to the collection. It can be annoying in some cases : for instance, if the <code>ListBox</code> is used to display search results, the user expects to see the results as they are found, like in Windows Search.  A simple way to achieve the desired behavior is to inherit <code>ObservableCollection</code> and override <code>OnCollectionChanged</code> and <code>OnPropertyChanged</code> so that the events are raised on the main thread (actually, the thread that created the collection). The <code>AsyncOperation</code> class is perfectly suited for this need : it allows to &ldquo;post&rdquo; a method call on the thread that created it. It is used, for instance, in the <code>BackgroundWorker</code> component, and in many asynchronous methods in the framework (<code>PictureBox.LoadAsync</code>, <code>WebClient.DownloadAsync</code>, etc&hellip;).  So, here&rsquo;s the code of an <code>AsyncObservableCollection</code> class, that can be modified from any thread, and still notify the UI when it is modified :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AsyncObservableCollection</span>&lt;T&gt; : ObservableCollection&lt;T&gt;
    {
        <span style="color:#66d9ef">private</span> AsyncOperation asyncOp = <span style="color:#66d9ef">null</span>;

        <span style="color:#66d9ef">public</span> AsyncObservableCollection()
        {
            CreateAsyncOp();
        }

        <span style="color:#66d9ef">public</span> AsyncObservableCollection(IEnumerable&lt;T&gt; list)
            : <span style="color:#66d9ef">base</span>(list)
        {
            CreateAsyncOp();
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> CreateAsyncOp()
        {
            <span style="color:#75715e">// Create the AsyncOperation to post events on the creator thread
</span><span style="color:#75715e"></span>            asyncOp = AsyncOperationManager.CreateOperation(<span style="color:#66d9ef">null</span>);
        }

        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> OnCollectionChanged(NotifyCollectionChangedEventArgs e)
        {
            <span style="color:#75715e">// Post the CollectionChanged event on the creator thread
</span><span style="color:#75715e"></span>            asyncOp.Post(RaiseCollectionChanged, e);
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> RaiseCollectionChanged(<span style="color:#66d9ef">object</span> param)
        {
            <span style="color:#75715e">// We are in the creator thread, call the base implementation directly
</span><span style="color:#75715e"></span>           <span style="color:#66d9ef">base</span>.OnCollectionChanged((NotifyCollectionChangedEventArgs)param);
        }

        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> OnPropertyChanged(PropertyChangedEventArgs e)
        {
            <span style="color:#75715e">// Post the PropertyChanged event on the creator thread
</span><span style="color:#75715e"></span>            asyncOp.Post(RaisePropertyChanged, e);
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> RaisePropertyChanged(<span style="color:#66d9ef">object</span> param)
        {
            <span style="color:#75715e">// We are in the creator thread, call the base implementation directly
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">base</span>.OnPropertyChanged((PropertyChangedEventArgs)param);
        }
    }
</code></pre></div><p>The only constraint when using this class is that instances of the collection must be created on the UI thread, so that events are raised on that thread.  In the previous example, the only thing to change to make the collection modifiable across threads is the instantiation of the collection in the ViewModel :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">
<span style="color:#66d9ef">private</span> ObservableCollection&lt;<span style="color:#66d9ef">string</span>&gt; _strings = <span style="color:#66d9ef">new</span> AsyncObservableCollection&lt;<span style="color:#66d9ef">string</span>&gt;();
</code></pre></div><p>The <code>ListBox</code> can now reflect in real-time the changes made on the collection.  Enjoy ;)  <strong>Update :</strong> I just found a bug in my implementation : in some cases, using <code>Post</code> to raise the event when the collection is modified from the main thread can cause unpredictable behavior. In that case, the event should of course be raised directly on the main thread, after checking that the current <code>SynchronizationContext</code> is the one in which the collection was created. This also made me realize that the <code>AsyncOperation</code> actually doesn&rsquo;t bring any benefit : we can use the <code>SynchronizationContext</code> directly instead. So here&rsquo;s the new implementation :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AsyncObservableCollection</span>&lt;T&gt; : ObservableCollection&lt;T&gt;
    {
        <span style="color:#66d9ef">private</span> SynchronizationContext _synchronizationContext = SynchronizationContext.Current;

        <span style="color:#66d9ef">public</span> AsyncObservableCollection()
        {
        }

        <span style="color:#66d9ef">public</span> AsyncObservableCollection(IEnumerable&lt;T&gt; list)
            : <span style="color:#66d9ef">base</span>(list)
        {
        }

        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> OnCollectionChanged(NotifyCollectionChangedEventArgs e)
        {
            <span style="color:#66d9ef">if</span> (SynchronizationContext.Current == _synchronizationContext)
            {
                <span style="color:#75715e">// Execute the CollectionChanged event on the current thread
</span><span style="color:#75715e"></span>                RaiseCollectionChanged(e);
            }
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#75715e">// Raises the CollectionChanged event on the creator thread
</span><span style="color:#75715e"></span>                _synchronizationContext.Send(RaiseCollectionChanged, e);
            }
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> RaiseCollectionChanged(<span style="color:#66d9ef">object</span> param)
        {
            <span style="color:#75715e">// We are in the creator thread, call the base implementation directly
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">base</span>.OnCollectionChanged((NotifyCollectionChangedEventArgs)param);
        }

        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> OnPropertyChanged(PropertyChangedEventArgs e)
        {
            <span style="color:#66d9ef">if</span> (SynchronizationContext.Current == _synchronizationContext)
            {
                <span style="color:#75715e">// Execute the PropertyChanged event on the current thread
</span><span style="color:#75715e"></span>                RaisePropertyChanged(e);
            }
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#75715e">// Raises the PropertyChanged event on the creator thread
</span><span style="color:#75715e"></span>                _synchronizationContext.Send(RaisePropertyChanged, e);
            }
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> RaisePropertyChanged(<span style="color:#66d9ef">object</span> param)
        {
            <span style="color:#75715e">// We are in the creator thread, call the base implementation directly
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">base</span>.OnPropertyChanged((PropertyChangedEventArgs)param);
        }
    }
</code></pre></div><p><strong>Update:</strong> changed the code to use <code>Send</code> instead of <code>Post</code>. Using <code>Post</code> caused the event to be raised <em>asynchronously</em> on the UI thread, which could cause a race condition if the collection was modified again before the previous event was handled.</p>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/asynchronous" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">asynchronous</a>
   </li>
  
   <li class="list">
     <a href="/tags/binding" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">binding</a>
   </li>
  
   <li class="list">
     <a href="/tags/collection" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">collection</a>
   </li>
  
   <li class="list">
     <a href="/tags/mvvm" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">MVVM</a>
   </li>
  
   <li class="list">
     <a href="/tags/wpf" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">WPF</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/2009/03/27/wpf-automatically-sort-a-gridview-when-a-column-header-is-clicked/">[WPF] Automatically sort a GridView when a column header is clicked</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2009/03/17/wpf-using-inputbindings-with-the-mvvm-pattern/">[WPF] Using InputBindings with the MVVM pattern</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2009/02/25/wpf-article-about-model-view-viewmodel-design-pattern-by-josh-smith/">[WPF] Article about the Model-View-ViewModel design pattern, by Josh Smith</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2008/11/18/wpf-binding-to-application-settings-using-a-markup-extension/">[WPF] Binding to application settings using a markup extension</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2009/02/13/build-an-rss-reader-in-5-minutes/">Build an RSS reader in 5 minutes</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2009/02/05/wpf-paste-an-image-from-the-clipboard/">[WPF] Paste an image from the clipboard (bug in Clipboard.GetImage)</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://blog2.thomaslevesque.net/" >
    &copy;  Thomas Levesque .NET Blog 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
