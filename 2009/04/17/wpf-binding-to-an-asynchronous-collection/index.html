<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>[WPF] Binding to an asynchronous collection - Thomas Levesque&#39;s .NET Blog</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	
	
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-31621259-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Thomas Levesque&#39;s .NET Blog" rel="home">
				<div class="logo__title">Thomas Levesque&#39;s .NET Blog</div>
				
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[WPF] Binding to an asynchronous collection</h1>
			
		</header><div class="content post__content clearfix">
			<p>As you may have noticed, it is not possible to modify the contents of an <code>ObservableCollection</code> on a separate thread if a view is bound to this collection : the <code>CollectionView</code> raises a <code>NotSupportedException</code> :</p>
<blockquote>
<p>This type of CollectionView does not support changes to its SourceCollection from a thread different from the Dispatcher thread</p>
</blockquote>
<p>To illustrate this, let&rsquo;s take a simple example : a <code>ListBox</code> bound to a collection of strings in the ViewModel :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">        <span style="color:#66d9ef">private</span> ObservableCollection&lt;<span style="color:#66d9ef">string</span>&gt; _strings = <span style="color:#66d9ef">new</span> ObservableCollection&lt;<span style="color:#66d9ef">string</span>&gt;();
        <span style="color:#66d9ef">public</span> ObservableCollection&lt;<span style="color:#66d9ef">string</span>&gt; Strings
        {
            <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> _strings; }
            <span style="color:#66d9ef">set</span>
            {
                _strings = <span style="color:#66d9ef">value</span>;
                OnPropertyChanged(<span style="color:#e6db74">&#34;Strings&#34;</span>);
            }
        }
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;ListBox</span> <span style="color:#a6e22e">ItemsSource=</span><span style="color:#e6db74">&#34;{Binding Strings}&#34;</span><span style="color:#f92672">/&gt;</span>
</code></pre></div><p>If we add items to this collection out of the main thread, we get the exception mentioned above. A possible solution would be to create a new collection, and assign it to the <code>Strings</code> property when it is filled, but in this case the UI won&rsquo;t reflect progress : all items will appear in the <code>ListBox</code> at the same time after the collection is filled, instead of appearing as they are added to the collection. It can be annoying in some cases : for instance, if the <code>ListBox</code> is used to display search results, the user expects to see the results as they are found, like in Windows Search.  A simple way to achieve the desired behavior is to inherit <code>ObservableCollection</code> and override <code>OnCollectionChanged</code> and <code>OnPropertyChanged</code> so that the events are raised on the main thread (actually, the thread that created the collection). The <code>AsyncOperation</code> class is perfectly suited for this need : it allows to &ldquo;post&rdquo; a method call on the thread that created it. It is used, for instance, in the <code>BackgroundWorker</code> component, and in many asynchronous methods in the framework (<code>PictureBox.LoadAsync</code>, <code>WebClient.DownloadAsync</code>, etc&hellip;).  So, here&rsquo;s the code of an <code>AsyncObservableCollection</code> class, that can be modified from any thread, and still notify the UI when it is modified :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AsyncObservableCollection</span>&lt;T&gt; : ObservableCollection&lt;T&gt;
    {
        <span style="color:#66d9ef">private</span> AsyncOperation asyncOp = <span style="color:#66d9ef">null</span>;

        <span style="color:#66d9ef">public</span> AsyncObservableCollection()
        {
            CreateAsyncOp();
        }

        <span style="color:#66d9ef">public</span> AsyncObservableCollection(IEnumerable&lt;T&gt; list)
            : <span style="color:#66d9ef">base</span>(list)
        {
            CreateAsyncOp();
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> CreateAsyncOp()
        {
            <span style="color:#75715e">// Create the AsyncOperation to post events on the creator thread
</span><span style="color:#75715e"></span>            asyncOp = AsyncOperationManager.CreateOperation(<span style="color:#66d9ef">null</span>);
        }

        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> OnCollectionChanged(NotifyCollectionChangedEventArgs e)
        {
            <span style="color:#75715e">// Post the CollectionChanged event on the creator thread
</span><span style="color:#75715e"></span>            asyncOp.Post(RaiseCollectionChanged, e);
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> RaiseCollectionChanged(<span style="color:#66d9ef">object</span> param)
        {
            <span style="color:#75715e">// We are in the creator thread, call the base implementation directly
</span><span style="color:#75715e"></span>           <span style="color:#66d9ef">base</span>.OnCollectionChanged((NotifyCollectionChangedEventArgs)param);
        }

        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> OnPropertyChanged(PropertyChangedEventArgs e)
        {
            <span style="color:#75715e">// Post the PropertyChanged event on the creator thread
</span><span style="color:#75715e"></span>            asyncOp.Post(RaisePropertyChanged, e);
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> RaisePropertyChanged(<span style="color:#66d9ef">object</span> param)
        {
            <span style="color:#75715e">// We are in the creator thread, call the base implementation directly
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">base</span>.OnPropertyChanged((PropertyChangedEventArgs)param);
        }
    }
</code></pre></div><p>The only constraint when using this class is that instances of the collection must be created on the UI thread, so that events are raised on that thread.  In the previous example, the only thing to change to make the collection modifiable across threads is the instantiation of the collection in the ViewModel :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">private</span> ObservableCollection&lt;<span style="color:#66d9ef">string</span>&gt; _strings = <span style="color:#66d9ef">new</span> AsyncObservableCollection&lt;<span style="color:#66d9ef">string</span>&gt;();
</code></pre></div><p>The <code>ListBox</code> can now reflect in real-time the changes made on the collection.  Enjoy ;)  <strong>Update :</strong> I just found a bug in my implementation : in some cases, using <code>Post</code> to raise the event when the collection is modified from the main thread can cause unpredictable behavior. In that case, the event should of course be raised directly on the main thread, after checking that the current <code>SynchronizationContext</code> is the one in which the collection was created. This also made me realize that the <code>AsyncOperation</code> actually doesn&rsquo;t bring any benefit : we can use the <code>SynchronizationContext</code> directly instead. So here&rsquo;s the new implementation :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AsyncObservableCollection</span>&lt;T&gt; : ObservableCollection&lt;T&gt;
    {
        <span style="color:#66d9ef">private</span> SynchronizationContext _synchronizationContext = SynchronizationContext.Current;

        <span style="color:#66d9ef">public</span> AsyncObservableCollection()
        {
        }

        <span style="color:#66d9ef">public</span> AsyncObservableCollection(IEnumerable&lt;T&gt; list)
            : <span style="color:#66d9ef">base</span>(list)
        {
        }

        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> OnCollectionChanged(NotifyCollectionChangedEventArgs e)
        {
            <span style="color:#66d9ef">if</span> (SynchronizationContext.Current == _synchronizationContext)
            {
                <span style="color:#75715e">// Execute the CollectionChanged event on the current thread
</span><span style="color:#75715e"></span>                RaiseCollectionChanged(e);
            }
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#75715e">// Raises the CollectionChanged event on the creator thread
</span><span style="color:#75715e"></span>                _synchronizationContext.Send(RaiseCollectionChanged, e);
            }
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> RaiseCollectionChanged(<span style="color:#66d9ef">object</span> param)
        {
            <span style="color:#75715e">// We are in the creator thread, call the base implementation directly
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">base</span>.OnCollectionChanged((NotifyCollectionChangedEventArgs)param);
        }

        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> OnPropertyChanged(PropertyChangedEventArgs e)
        {
            <span style="color:#66d9ef">if</span> (SynchronizationContext.Current == _synchronizationContext)
            {
                <span style="color:#75715e">// Execute the PropertyChanged event on the current thread
</span><span style="color:#75715e"></span>                RaisePropertyChanged(e);
            }
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#75715e">// Raises the PropertyChanged event on the creator thread
</span><span style="color:#75715e"></span>                _synchronizationContext.Send(RaisePropertyChanged, e);
            }
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> RaisePropertyChanged(<span style="color:#66d9ef">object</span> param)
        {
            <span style="color:#75715e">// We are in the creator thread, call the base implementation directly
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">base</span>.OnPropertyChanged((PropertyChangedEventArgs)param);
        }
    }
</code></pre></div><p><strong>Update:</strong> changed the code to use <code>Send</code> instead of <code>Post</code>. Using <code>Post</code> caused the event to be raised <em>asynchronously</em> on the UI thread, which could cause a race condition if the collection was modified again before the previous event was handled.</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/asynchronous/" rel="tag">asynchronous</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/binding/" rel="tag">binding</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/collection/" rel="tag">collection</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/mvvm/" rel="tag">MVVM</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/wpf/" rel="tag">WPF</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>





			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 Thomas Levesque&#39;s .NET Blog.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>